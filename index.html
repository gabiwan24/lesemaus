<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Lese-Lern-App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playwrite+DE+Grund:wght@100..400&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Playwrite DE Grund', cursive;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            background-color: #f9fafb;
        }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }

        .animate-pop-in { animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes popIn { 0% { opacity: 0; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }

        .card-shadow { box-shadow: 0 4px 0 rgba(0,0,0,0.15), 0 8px 16px rgba(0,0,0,0.1); }

        #swipe-feedback-bg { transition: background-color 0.15s ease-out; will-change: background-color; }
        .fade-out { animation: fadeOut 0.5s ease-out forwards; }
        @keyframes fadeOut { from { opacity: 1; visibility: visible; } to { opacity: 0; visibility: hidden; } }
    </style>
</head>
<body class="w-screen h-[100dvh] overflow-hidden flex flex-col select-none">

    <div id="intro-screen" class="fixed inset-0 z-[100] bg-white flex items-center justify-center transition-opacity duration-500">
        <h1 class="text-5xl md:text-7xl font-bold text-blue-600 animate-bounce">Lesemaus</h1>
    </div>

    <div id="swipe-feedback-bg" class="absolute inset-0 z-0 pointer-events-none"></div>

    <div id="app" class="relative w-full h-full z-10 flex flex-col hidden opacity-0 transition-opacity duration-500">

        <!-- 1. EINSTELLUNGEN -->
        <div id="startbildschirm" class="flex flex-col h-full p-3 bg-white z-50 relative">
            <h1 class="text-2xl font-bold text-center text-blue-600 mb-2 mt-1 shrink-0">Lese-Training</h1>

            <div class="flex-grow flex flex-col gap-2 overflow-hidden">
                
                <!-- Heft Auswahl -->
                <div class="mb-1 shrink-0">
                    <label class="block text-xs font-bold text-gray-500 uppercase tracking-wider mb-1">1. Arbeitsheft</label>
                    <select id="heft-auswahl" class="w-full p-2.5 border-2 border-blue-100 rounded-xl bg-blue-50 text-blue-800 font-bold text-lg focus:outline-none focus:border-blue-500 appearance-none">
                        <!-- Optionen per JS -->
                    </select>
                </div>

                <!-- Gelernte Buchstaben (Nur aktuelles Heft) -->
                <fieldset class="border border-gray-200 rounded-xl p-2 flex flex-col min-h-0 shrink transition-all duration-300">
                    <legend class="text-sm font-semibold px-2 text-gray-500">2. Neue Buchstaben</legend>
                    <div class="text-[10px] text-gray-400 px-1 mb-1 italic">Bereits gelernt (automatisch aktiv): <span id="prev-letters-list" class="font-bold text-gray-500">-</span></div>
                    <div class="overflow-y-auto px-1">
                        <div id="buchstaben-container" class="grid grid-cols-4 sm:grid-cols-6 gap-2 pb-1">
                            <!-- Checkboxen nur f√ºr aktuelles Heft -->
                        </div>
                    </div>
                </fieldset>

                <!-- Optionen -->
                <fieldset class="border border-gray-200 rounded-xl p-2 shrink-0">
                    <legend class="text-sm font-semibold px-2 text-gray-500">Optionen</legend>
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <div>
                            <label id="lbl-min" class="block text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-0.5 text-center whitespace-nowrap">Min 1 Silbe</label>
                            <input type="number" id="min-silben" value="1" min="1" max="5" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-gray-50 text-lg font-bold">
                        </div>
                        <div>
                            <label id="lbl-max" class="block text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-0.5 text-center whitespace-nowrap">Max 2 Silben</label>
                            <input type="number" id="max-silben" value="2" min="1" max="5" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-gray-50 text-lg font-bold">
                        </div>
                    </div>

                    <div class="mb-2">
                        <div class="flex rounded-lg overflow-hidden border border-gray-200 mb-2 bg-gray-50">
                            <button id="btn-mode-count" class="mode-btn flex-1 py-1.5 text-sm font-bold bg-blue-600 text-white transition-colors">Anzahl</button>
                            <button id="btn-mode-time" class="mode-btn flex-1 py-1.5 text-sm font-bold bg-transparent text-gray-600 transition-colors">Zeit</button>
                        </div>
                        
                        <div id="input-container-count" class="block">
                            <input type="number" id="woerter-pro-runde" value="10" min="1" max="50" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-white text-lg font-bold placeholder-gray-400" placeholder="Anzahl W√∂rter">
                        </div>
                        <div id="input-container-time" class="hidden">
                            <input type="number" id="zeit-limit" value="5" min="1" max="20" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-white text-lg font-bold placeholder-gray-400" placeholder="Minuten">
                        </div>
                    </div>
                    
                    <div class="flex justify-between gap-2">
                        <div class="flex-1 bg-gray-50 p-1.5 rounded-lg flex items-center justify-center gap-2 border border-gray-100 px-2">
                            <input id="silben-faerben" type="checkbox" checked class="h-5 w-5 text-blue-600 rounded flex-shrink-0">
                            <label for="silben-faerben" class="text-xs font-medium text-gray-600">Bunt</label>
                        </div>
                        <div class="flex-1 bg-gray-50 p-1.5 rounded-lg flex items-center justify-center gap-2 border border-gray-100 px-2">
                            <input id="silben-abstand" type="checkbox" class="h-5 w-5 text-blue-600 rounded flex-shrink-0">
                            <label for="silben-abstand" class="text-xs font-medium text-gray-600">Abstand</label>
                        </div>
                    </div>
                </fieldset>
            </div>

            <div class="shrink-0 pt-3 pb-2 safe-area-pb">
                <button id="start-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-3.5 rounded-xl shadow-lg active:scale-95 transition-transform">
                    Start!
                </button>
            </div>
        </div>

        <!-- 2. SPIELFELD -->
        <div id="spiel" class="hidden w-full h-full relative flex flex-col">
            <div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-start z-50 pointer-events-none">
                <div class="flex flex-col gap-2 pointer-events-auto items-start">
                    <button id="stop-button" class="hidden bg-red-100 text-red-600 hover:bg-red-200 font-bold text-xs px-3 py-2 rounded-full shadow-sm border border-red-200 mb-1 transition-all active:scale-95">
                        <span class="flex items-center gap-1"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z"/></svg> Beenden</span>
                    </button>
                    <div class="flex gap-2">
                        <div id="fortschritt-anzeige" class="text-blue-600 font-mono font-bold text-lg bg-white/90 backdrop-blur px-3 py-1 rounded-full shadow-sm border border-gray-100 flex items-center">
                            <span id="fortschritt-text">1 / 10</span>
                        </div>
                        <div id="timer-display" class="text-blue-600 font-mono font-bold text-lg bg-white/90 backdrop-blur px-3 py-1 rounded-full shadow-sm border border-gray-100 flex items-center">00:00</div>
                    </div>
                </div>
                <button id="einstellungen-button" class="text-gray-400 hover:text-blue-600 bg-white/90 backdrop-blur p-2 rounded-full shadow-sm border border-gray-100 pointer-events-auto active:scale-90 transition-transform">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                </button>
            </div>
            <div id="2d-canvas-container" class="absolute inset-0 z-0 w-full h-full"></div>
            <div class="absolute inset-0 z-30 flex items-center justify-center pointer-events-none p-4 pb-20">
                <div id="card-swipe-layer" class="w-full max-w-xs aspect-[3/2] pointer-events-auto cursor-grab active:cursor-grabbing touch-none select-none will-change-transform relative">
                    <div id="card-content-layer" class="w-full h-full bg-white rounded-3xl card-shadow border border-gray-200 flex items-center justify-center relative overflow-hidden bg-white select-none transition-colors duration-150">
                        <div id="wort-anzeige-container" class="w-full h-full flex items-center justify-center p-4 relative z-10 pointer-events-none">
                            <span id="wort-anzeige" class="font-bold whitespace-nowrap select-none text-gray-800 leading-none"></span>
                        </div>
                        <div id="card-overlay" class="absolute inset-0 z-20 flex items-center justify-center opacity-0 transition-opacity duration-150 bg-transparent pointer-events-none"></div>
                    </div>
                </div>
            </div>
            <div id="los-button-container" class="hidden absolute bottom-10 left-0 right-0 flex justify-center z-50 pointer-events-none">
                <button id="los-button" class="pointer-events-auto bg-blue-600 hover:bg-blue-700 text-white font-bold text-3xl py-3 px-12 rounded-full shadow-xl transition-transform duration-150 hover:scale-105 active:scale-95 animate-bounce">Los!</button>
            </div>
        </div>

        <!-- 3. AUSWERTUNG -->
        <div id="auswertung" class="hidden absolute inset-0 z-[60] bg-white flex flex-col justify-center items-center p-6">
            <h2 class="text-5xl font-bold text-blue-600 mb-8 drop-shadow-sm">Super!</h2>
            <div id="tier-bild-container" class="w-full max-w-xs h-40 mb-8 flex items-center justify-center text-gray-300 text-6xl">ü¶Å</div>
            <div class="bg-gray-50 p-6 rounded-2xl border border-gray-100 mb-12 w-full max-w-xs text-center">
                <p class="text-gray-500 text-lg mb-1">Ergebnis</p>
                <p class="text-3xl font-bold text-gray-800 mb-2"><span id="richtige-woerter-anzahl" class="text-green-600">0</span> richtig</p>
                <p class="text-lg text-gray-500">Zeit: <span id="gesamt-zeit-anzeige" class="font-mono text-gray-700">00:00</span></p>
            </div>
            <button id="zurueck-button" class="w-full max-w-xs bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-4 rounded-xl shadow-lg active:scale-95 transition-transform">Nochmal spielen</button>
        </div>
    </div>

    <script>
        // --- HEFTE STRUKTUR ---
        const HEFTE = [
            { name: "Heft 1 (Start M,A,L...)", buchstaben: ['M', 'A', 'L', 'I', 'O', 'S'] },
            { name: "Heft 2 (E,N,D...)", buchstaben: ['E', 'N', 'D', 'U', 'P', 'K'] },
            { name: "Heft 3 (Erweiterung)", buchstaben: ['H', 'T', 'R', 'F', 'W', 'Ei', 'Au', 'Eu'] },
            { name: "Heft 4 (Komplett)", buchstaben: ['B', 'G', 'J', 'Z', 'Ch', 'Sch', 'Ck', '√Ñ', '√ñ', '√ú', 'V', 'X', 'Y', 'Q'] }
        ];

        // --- WORTSCHATZ (Erweitert f√ºr alle Hefte) ---
        const WOERTERBUCH = [
            // Heft 1 (M, A, L, I, O, S)
            ['Ma', 'ma'], ['Pa', 'pa'], ['O', 'ma'], ['O', 'pa'], ['La', 'ma'], ['Li', 'mo'], ['Li', 'la'], ['Lo', 'la'], ['Ma', 'li'], ['Mi', 'mi'], ['Sa', 'la', 'mi'], ['Sa', 'lat'], ['So', 'fa'], ['Li', 'sa'],
            // Heft 2 (E, N, D, U, P, K)
            ['En', 'te'], ['E', 'sel'], ['Na', 'se'], ['No', 'te'], ['Nu', 'del'], ['Na', 'del'], ['Dos', 'e'], ['Mon', 'd'], ['Un', 'd'], ['Hu', 'nd'], ['Ka', 'nu'], ['Pa', 'pa'], ['Pa', 'ket'], ['Pin', 'sel'], ['Pup', 'pe'], ['Lam', 'pe'], ['Am', 'pel'], ['Kin', 'd'], ['Ki', 'no'], ['Kis', 'te'], ['Klas', 'se'], ['Ka', 'me', 'l'], ['In', 'sel'], ['San', 'd'], ['Son', 'ne'], ['To', 'ma', 'te'], ['Me', 'lo', 'ne'], ['Ba', 'na', 'ne'], ['Man', 'tel'], ['Kap', 'pe'], ['Tas', 'se'],
            // Heft 3 & 4
            ['Hut'], ['Haus'], ['Baum'], ['Ball'], ['Buch'], ['Fi', 'sch'], ['Vo', 'gel'], ['Blu', 'me'], ['Wol', 'ke'], ['Re', 'gen'], ['Schnee'], ['Eis'], ['Wa', 'l'], ['Zeb', 'ra'], ['L√∂', 'we'], ['Ti', 'ger'], ['En', 'te'], ['Gans'], ['Huhn'], ['Kuh'], ['Scha', 'f'], ['Pferd'], ['Au', 'to'], ['Bus'], ['Zug'], ['Schiff'], ['See'], ['Tee'], ['Fee'], ['Klee']
        ];

        const VOKALE_LISTE = ['A', 'E', 'I', 'O', 'U', '√Ñ', '√ñ', '√ú'];
        const DIPHTHONGE_LISTE = ['Ei', 'Ai', 'Eu', 'Au'];
        const RAINBOW_COLORS = ['#9C4F96', '#FF6355', '#FBA949', '#FAE442', '#8BD448', '#2AA8F2'];

        // --- STATE ---
        const state = {
            settings: { 
                heftIndex: 1, currentLetters: [], mode: 'count', targetValue: 10, 
                minSilben: 1, maxSilben: 2, farben: true, abstand: false 
            },
            game: { 
                runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: false, finished: false,
                letterStats: {}, wordStartTime: 0, startTimeGlobal: 0, timerInterval: null
            },
            view: { zoom: 1, targetZoom: 1 }
        };

        // --- DOM ---
        const dom = {
            intro: document.getElementById('intro-screen'), app: document.getElementById('app'),
            views: { start: document.getElementById('startbildschirm'), spiel: document.getElementById('spiel'), ende: document.getElementById('auswertung') },
            inputs: { heftSelect: document.getElementById('heft-auswahl'), container: document.getElementById('buchstaben-container'), prevList: document.getElementById('prev-letters-list'), min: document.getElementById('min-silben'), max: document.getElementById('max-silben'), modeCount: document.getElementById('btn-mode-count'), modeTime: document.getElementById('btn-mode-time'), countInput: document.getElementById('input-container-count'), timeInput: document.getElementById('input-container-time'), valCount: document.getElementById('woerter-pro-runde'), valTime: document.getElementById('zeit-limit'), color: document.getElementById('silben-faerben'), gap: document.getElementById('silben-abstand'), lblMin: document.getElementById('lbl-min'), lblMax: document.getElementById('lbl-max') },
            btns: { start: document.getElementById('start-button'), settings: document.getElementById('einstellungen-button'), back: document.getElementById('zurueck-button'), los: document.getElementById('los-button'), stop: document.getElementById('stop-button') },
            card: { swipe: document.getElementById('card-swipe-layer'), content: document.getElementById('card-content-layer'), textContainer: document.getElementById('wort-anzeige-container'), text: document.getElementById('wort-anzeige'), overlay: document.getElementById('card-overlay'), bg: document.getElementById('swipe-feedback-bg') },
            stats: { progressText: document.getElementById('fortschritt-text'), timer: document.getElementById('timer-display'), resRight: document.getElementById('richtige-woerter-anzahl'), resTime: document.getElementById('gesamt-zeit-anzeige') },
            misc: { losContainer: document.getElementById('los-button-container') }
        };

        let engine, render, runner, stirrer, physicsActive = false;

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            try {
                initHeftSelection();
                ladeEinstellungen();
                initSwipeLogic();
                startAppSequence();
                
                dom.btns.start.onclick = startGame;
                dom.btns.settings.onclick = showStart;
                dom.btns.back.onclick = showStart;
                dom.btns.los.onclick = triggerExplosion;
                dom.inputs.heftSelect.onchange = handleHeftChange;
                dom.inputs.modeCount.onclick = () => setMode('count');
                dom.inputs.modeTime.onclick = () => setMode('time');
                dom.inputs.min.addEventListener('input', updateLabels);
                dom.inputs.max.addEventListener('input', updateLabels);
                
                dom.btns.stop.onclick = () => {
                    if (state.game.finished) { showEnd(); return; }
                    if (dom.btns.stop.classList.contains('confirm-mode')) endGameTimeUp();
                    else {
                        dom.btns.stop.classList.add('confirm-mode', 'bg-red-600', 'text-white', 'border-red-600');
                        dom.btns.stop.innerHTML = 'Sicher?';
                        setTimeout(() => {
                            dom.btns.stop.classList.remove('confirm-mode', 'bg-red-600', 'text-white', 'border-red-600');
                            dom.btns.stop.innerHTML = '<span class="flex items-center gap-1"><svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z"/></svg> Beenden</span>';
                        }, 3000);
                    }
                };

                window.addEventListener('resize', () => { if(physicsActive) resizePhysics(); adjustFontSize(); });
                document.addEventListener('mousemove', moveStirrer);
                document.addEventListener('touchmove', moveStirrer, {passive: false});
                document.addEventListener('touchstart', moveStirrer, {passive: false});
                document.addEventListener('mousedown', moveStirrer);
            } catch (e) {
                dom.intro.style.display = 'none';
                dom.app.classList.remove('hidden');
                dom.app.style.opacity = '1';
                dom.views.start.classList.remove('hidden');
                dom.views.start.classList.add('flex');
            }
        });

        // --- HEFT LOGIK ---
        function initHeftSelection() {
            dom.inputs.heftSelect.innerHTML = HEFTE.map((h, i) => `<option value="${i}">${h.name}</option>`).join('');
        }

        function handleHeftChange() {
            const idx = parseInt(dom.inputs.heftSelect.value);
            updateBuchstabenUI(idx);
        }

        function updateBuchstabenUI(idx, savedSelection = null) {
            // 1. Vorherige Buchstaben (implizit aktiv)
            let prevLetters = [];
            for(let i=0; i<idx; i++) prevLetters = prevLetters.concat(HEFTE[i].buchstaben);
            prevLetters = [...new Set(prevLetters)]; // Unique
            
            dom.inputs.prevList.textContent = prevLetters.length > 0 ? prevLetters.join(', ') : '(Keine)';
            
            // 2. Aktuelle Buchstaben (Checkboxen)
            const currentLetters = HEFTE[idx].buchstaben;
            dom.inputs.container.innerHTML = currentLetters.map(b => {
                const checked = savedSelection ? savedSelection.includes(b) : true;
                return `
                <div class="flex items-center justify-center">
                    <input type="checkbox" id="cb-${b}" value="${b}" class="peer hidden" ${checked ? 'checked' : ''}>
                    <label for="cb-${b}" class="w-full text-center py-2 border-2 border-gray-200 rounded-lg cursor-pointer text-gray-600 font-bold select-none transition-colors peer-checked:border-blue-500 peer-checked:bg-blue-50 peer-checked:text-blue-600 text-sm sm:text-base bg-white shadow-sm hover:bg-gray-50">${b}</label>
                </div>`;
            }).join('');
        }

        // Helper: Holt ALLE erlaubten Buchstaben (Implizit + Explizit)
        function getAllAllowedLetters() {
            const idx = parseInt(dom.inputs.heftSelect.value);
            let allowed = [];
            // Vorherige Hefte
            for(let i=0; i<idx; i++) allowed = allowed.concat(HEFTE[i].buchstaben);
            // Aktuelles Heft (nur Checked)
            const checked = Array.from(dom.inputs.container.querySelectorAll('input:checked')).map(c => c.value);
            allowed = allowed.concat(checked);
            return [...new Set(allowed)];
        }

        function setMode(mode) {
            state.settings.mode = mode;
            const isCount = mode === 'count';
            dom.inputs.modeCount.className = `mode-btn flex-1 py-1.5 text-sm font-bold transition-colors ${isCount ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-600'}`;
            dom.inputs.modeTime.className = `mode-btn flex-1 py-1.5 text-sm font-bold transition-colors ${!isCount ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-600'}`;
            dom.inputs.countInput.classList.toggle('hidden', !isCount);
            dom.inputs.timeInput.classList.toggle('hidden', isCount);
        }

        function updateLabels() {
            dom.inputs.lblMin.textContent = `Min. ${dom.inputs.min.value} Silben`;
            dom.inputs.lblMax.textContent = `Max. ${dom.inputs.max.value} Silben`;
        }

        function startAppSequence() {
            setTimeout(() => {
                dom.intro.classList.add('fade-out');
                setTimeout(() => {
                    dom.intro.style.display = 'none';
                    dom.app.classList.remove('hidden');
                    void dom.app.offsetWidth;
                    dom.app.style.opacity = '1';
                    dom.views.start.classList.remove('hidden');
                    dom.views.start.classList.add('flex');
                }, 500);
            }, 1500);
        }

        // --- GAME LOOP ---
        function startGame() {
            saveSettings();
            
            // State Init
            state.settings.currentLetters = getAllAllowedLetters();
            state.game = { runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: true, finished: false, letterStats: {}, startTimeGlobal: Date.now(), timerInterval: null };
            state.settings.currentLetters.forEach(b => state.game.letterStats[b] = 0);
            state.view = { zoom: 1, targetZoom: 1 };

            // UI Reset
            dom.views.start.classList.add('hidden'); dom.views.start.classList.remove('flex');
            dom.views.ende.classList.add('hidden'); dom.views.ende.classList.remove('flex');
            dom.views.spiel.classList.remove('hidden'); dom.views.spiel.classList.add('flex');
            
            dom.misc.losContainer.classList.add('hidden');
            dom.card.swipe.classList.remove('hidden');
            
            // Reset Card
            dom.card.swipe.style.transition = 'none';
            dom.card.swipe.style.transform = 'scale(1)';
            dom.card.swipe.style.opacity = '1';
            dom.card.content.classList.remove('animate-pop-in');
            dom.card.overlay.style.opacity = '0';

            // Mode Specifics
            if(state.settings.mode === 'time') {
                dom.btns.stop.classList.remove('hidden');
                dom.stats.progressText.parentElement.classList.remove('hidden');
                dom.stats.progressText.textContent = "0 W√∂rter";
            } else {
                dom.btns.stop.classList.add('hidden');
                dom.stats.progressText.parentElement.classList.remove('hidden');
            }

            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            state.game.timerInterval = setInterval(updateTimer, 1000);
            updateTimer();

            startPhysics();
            setTimeout(() => nextCard(true), 50);
        }

        function updateTimer() {
            const now = Date.now();
            let diff = 0;
            if (state.settings.mode === 'count') {
                diff = now - state.game.startTimeGlobal;
            } else {
                const endTime = state.game.startTimeGlobal + (state.settings.targetValue * 60 * 1000);
                diff = endTime - now;
                if (diff <= 0) { diff = 0; endGameTimeUp(); return; }
            }
            const sec = Math.floor(diff / 1000);
            dom.stats.timer.textContent = `${Math.floor(sec/60).toString().padStart(2,'0')}:${(sec%60).toString().padStart(2,'0')}`;
        }

        function showStart() {
            state.game.active = false;
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            stopPhysics();
            dom.views.spiel.classList.add('hidden'); dom.views.ende.classList.add('hidden');
            dom.views.start.classList.remove('hidden'); dom.views.start.classList.add('flex');
            dom.card.content.style.backgroundColor = 'white';
        }

        function endGameTimeUp() {
            if (state.game.finished) return;
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            state.game.finished = true;
            dom.card.swipe.classList.add('hidden');
            if(world) Matter.Composite.allBodies(world).forEach(b => { Matter.Sleeping.set(b, false); b.sleepThreshold = -1; });
            if (state.settings.mode === 'time' && state.game.richtig === 0) showEnd();
        }

        function nextCard() {
            if (state.settings.mode === 'count' && state.game.runde >= state.settings.targetValue) { prepareEndPhase(); return; }
            if (state.settings.mode === 'time' && state.game.finished) return;

            dom.stats.progressText.textContent = state.settings.mode === 'count' ? `Wort ${state.game.runde + 1} / ${state.settings.targetValue}` : `${state.game.runde + 1} W√∂rter`;

            let wort = selectWordPriority();
            let versuche = 0;
            while (state.game.history.has(wort.join('')) && versuche < 20) { wort = selectWordPriority(); versuche++; }
            state.game.history.add(wort.join(''));
            
            const fullString = wort.join('').toUpperCase();
            state.settings.currentLetters.forEach(token => {
                if (fullString.includes(token.toUpperCase())) state.game.letterStats[token] = (state.game.letterStats[token] || 0) + 1;
            });

            dom.card.text.innerHTML = '';
            wort.forEach((silbe, i) => {
                const span = document.createElement('span');
                let text = silbe.toLowerCase();
                if (i === 0 && Math.random() < 0.8) text = text.charAt(0).toUpperCase() + text.slice(1);
                span.textContent = text;
                if (state.settings.farben) span.className = i % 2 === 0 ? 'text-blue-600' : 'text-red-600';
                if (state.settings.abstand && i < wort.length - 1) span.style.marginRight = '0.2em';
                dom.card.text.appendChild(span);
            });
            adjustFontSize();

            dom.card.swipe.style.transition = 'none';
            dom.card.swipe.style.transform = 'scale(0.8)';
            dom.card.swipe.style.opacity = '0';
            dom.card.overlay.style.opacity = '0';
            dom.card.content.style.backgroundColor = 'white';
            
            requestAnimationFrame(() => {
                dom.card.swipe.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                dom.card.swipe.style.transform = 'scale(1)';
                dom.card.swipe.style.opacity = '1';
                state.game.wordStartTime = Date.now();
            });
        }

        // --- WORT LOGIK ---
        function selectWordPriority() {
            const allowedCharsFlat = new Set();
            state.settings.currentLetters.forEach(t => t.toUpperCase().split('').forEach(c => allowedCharsFlat.add(c)));

            const candidates = WOERTERBUCH.filter(silben => {
                if(silben.length < state.settings.minSilben || silben.length > state.settings.maxSilben) return false;
                return silben.join('').toUpperCase().split('').every(c => allowedCharsFlat.has(c));
            });

            if (candidates.length > 0) {
                const unused = candidates.filter(w => !state.game.history.has(w.join('')));
                const pool = unused.length > 0 ? unused : candidates;
                // Sort by least used letters
                pool.sort((a, b) => scoreWord(b) - scoreWord(a));
                return pool[Math.floor(Math.random() * Math.min(pool.length, 5))];
            }
            
            const targetLen = Math.random() < 0.75 ? state.settings.maxSilben : Math.floor(Math.random() * (state.settings.maxSilben - state.settings.minSilben + 1)) + state.settings.minSilben;
            return generateFantasyWord(targetLen);
        }

        function scoreWord(silben) {
            let score = 0;
            const str = silben.join('').toUpperCase();
            state.settings.currentLetters.forEach(t => { if(str.includes(t.toUpperCase())) score += 1 / ((state.game.letterStats[t]||0) + 1); });
            return score;
        }

        function generateFantasyWord(len) {
            const res = [];
            const v = state.settings.currentLetters.filter(b => VOKALE_LISTE.includes(b));
            const k = state.settings.currentLetters.filter(b => !VOKALE_LISTE.includes(b) && !DIPHTHONGE_LISTE.includes(b));
            const d = state.settings.currentLetters.filter(b => DIPHTHONGE_LISTE.includes(b));
            if (v.length === 0 && d.length === 0) return ["A".repeat(len).split('')]; 

            for(let i=0; i<len; i++) {
                let s = '', attempts=0;
                do {
                    let type = 'KV';
                    if(Math.random() < 0.1) type = 'V';
                    s = '';
                    if(type==='KV' && k.length>0) s += pickWeighted(k);
                    if(d.length>0 && Math.random()<0.2) s += pickWeighted(d);
                    else if(v.length>0) s += pickWeighted(v);
                    attempts++;
                } while(len >= 3 && i > 0 && s === res[i-1] && attempts < 10);
                res.push(s);
            }
            return res;
        }

        function pickWeighted(pool) {
            let min = Infinity;
            pool.forEach(c => { const u = state.game.letterStats[c]||0; if(u<min) min=u; });
            const cands = pool.filter(c => (state.game.letterStats[c]||0) === min);
            return cands[Math.floor(Math.random()*cands.length)];
        }

        // --- RESTLICHE FUNKTIONEN (SWIPE, PHYSICS, ETC) SIND UNVER√ÑNDERT ---
        // Um Platz zu sparen, hier komprimiert, da die Logik identisch zum vorherigen stabilen Build ist.
        // Nur notwendige Anpassungen f√ºr die neuen Variablen (state.settings.currentLetters) wurden oben gemacht.
        
        function handleResult(success) {
            if (success) {
                state.game.richtig++;
                const dur = Date.now() - state.game.wordStartTime;
                let f = 1.0; if(dur<2000) f=2.0; else if(dur>5000) f=0.5;
                spawnParticles(f);
            }
            state.game.runde++;
            setTimeout(nextCard, 300);
        }

        function initSwipeLogic() {
            let startX = 0, isDragging = false; const card = dom.card.swipe; const content = dom.card.content;
            const start = (x) => { if (state.game.finished) return; startX = x; isDragging = true; card.style.transition = 'none'; };
            const move = (x) => {
                if (!isDragging) return; const diff = x - startX; card.style.transform = `translate(${diff}px, 0) rotate(${diff * 0.05}deg)`;
                const op = Math.min(Math.abs(diff) / 150, 0.3);
                if (diff > 0) { content.style.backgroundColor = `rgba(34, 197, 94, ${0.1 + op * 0.5})`; dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-green-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M5 13l4 4L19 7"></path></svg>`; } 
                else { content.style.backgroundColor = `rgba(107, 114, 128, ${0.1 + op * 0.5})`; dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-gray-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M6 18L18 6M6 6l12 12"></path></svg>`; }
                dom.card.overlay.style.opacity = Math.min(Math.abs(diff) / 100, 1);
            };
            const end = (x) => {
                if (!isDragging) return; isDragging = false; const diff = x - startX;
                if (Math.abs(diff) > 100) {
                    const dir = diff > 0 ? 1 : -1;
                    card.style.transition = 'transform 0.2s ease-out'; card.style.transform = `translate(${dir * 500}px, 0) rotate(${dir * 45}deg)`;
                    handleResult(dir === 1);
                } else {
                    card.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'; card.style.transform = 'translate(0,0) rotate(0)';
                    content.style.backgroundColor = 'white'; dom.card.overlay.style.opacity = '0';
                }
            };
            card.addEventListener('touchstart', e => start(e.touches[0].clientX)); window.addEventListener('touchmove', e => move(e.touches[0].clientX)); window.addEventListener('touchend', e => end(e.changedTouches[0].clientX));
            card.addEventListener('mousedown', e => start(e.clientX)); window.addEventListener('mousemove', e => move(e.clientX)); window.addEventListener('mouseup', e => end(e.clientX));
        }

        function startPhysics() {
            stopPhysics();
            const container = document.getElementById('2d-canvas-container');
            engine = Matter.Engine.create({ enableSleeping: true }); world = engine.world;
            render = Matter.Render.create({ element: container, engine: engine, options: { width: container.clientWidth, height: container.clientHeight, wireframes: false, background: 'transparent' } });
            createWalls(container.clientWidth, container.clientHeight);
            (function loop() {
                if (!engine) return; window.requestAnimationFrame(loop);
                Matter.Engine.update(engine, 1000/60);
                const ctx = render.context; ctx.clearRect(0, 0, w = render.canvas.width, h = render.canvas.height);
                ctx.save();
                state.view.zoom += (state.view.targetZoom - state.view.zoom) * 0.05;
                ctx.translate(w/2, h/2); ctx.scale(state.view.zoom, state.view.zoom); ctx.translate(-w/2, -h/2);
                Matter.Composite.allBodies(world).forEach(b => {
                    if (b.label === 'wall' || b.label === 'stirrer') return;
                    ctx.beginPath(); ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, 2*Math.PI);
                    ctx.fillStyle = b.render.fillStyle; ctx.fill();
                });
                ctx.restore();
            })();
            physicsActive = true;
        }
        function stopPhysics() { engine = null; render = null; stirrer = null; physicsActive = false; document.getElementById('2d-canvas-container').innerHTML = ''; }
        function resizePhysics() { if(!render) return; render.canvas.width = document.getElementById('2d-canvas-container').clientWidth; render.canvas.height = document.getElementById('2d-canvas-container').clientHeight; createWalls(render.canvas.width, render.canvas.height); }
        function createWalls(w, h) {
            if(!world) return; Matter.Composite.clear(world, false, true); const th = 200; const opts = { isStatic: true, label: 'wall', friction: 1 };
            Matter.Composite.add(world, [Matter.Bodies.rectangle(w/2, h+th/2, w+200, th, opts), Matter.Bodies.rectangle(-th/2, h/2, th, h*2, opts), Matter.Bodies.rectangle(w+th/2, h/2, th, h*2, opts)]);
        }
        function spawnParticles(factor=1) {
            if(!engine) return; const w = render.canvas.width; const h = render.canvas.height;
            if(state.settings.mode === 'time') {
                const body = Matter.Bodies.circle(Math.random()*w*0.8+w*0.1, -50, 45, { restitution: 0.1, friction: 0.5, render: { fillStyle: RAINBOW_COLORS[state.game.colorIndex] } });
                Matter.Composite.add(world, body);
            } else {
                let count = Math.floor(((w*h*0.85)/(Math.PI*15*15*3)/state.settings.targetValue)*1.5 * factor);
                if(count<10) count=10; if(count>150) count=150;
                for(let i=0; i<count; i++) {
                    const body = Matter.Bodies.circle(Math.random()*w*0.8+w*0.1, -Math.random()*300-50, 15, { restitution: 0.1, friction: 0.5, render: { fillStyle: RAINBOW_COLORS[state.game.colorIndex] } });
                    Matter.Composite.add(world, body);
                }
            }
            state.game.colorIndex = (state.game.colorIndex+1)%RAINBOW_COLORS.length;
        }
        function adjustFontSize() { const el = dom.card.text; const p = dom.card.textContainer; let s = 4; el.style.fontSize = `${s}rem`; while((el.scrollWidth > p.clientWidth || el.scrollHeight > p.clientHeight) && s > 1) { s-=0.2; el.style.fontSize = `${s}rem`; } }
        function moveStirrer(e) {
            if (!state.game.finished || dom.misc.losContainer.classList.contains('hidden')) return;
            if(e.type === 'touchmove') e.preventDefault();
            const x = e.touches ? e.touches[0].clientX : e.clientX; const y = e.touches ? e.touches[0].clientY : e.clientY;
            if (!stirrer && engine) { stirrer = Matter.Bodies.circle(x, y, 80, { isStatic: true, label: 'stirrer' }); Matter.Composite.add(engine.world, stirrer); }
            else if (stirrer) Matter.Body.setPosition(stirrer, {x, y});
        }
        function prepareEndPhase() {
            if(state.game.timerInterval) clearInterval(state.game.timerInterval); state.game.finished = true;
            dom.card.swipe.classList.add('hidden');
            if(state.settings.mode==='count') dom.misc.losContainer.classList.remove('hidden');
            else dom.misc.losContainer.classList.add('hidden');
            if(world) Matter.Composite.allBodies(world).forEach(b => { Matter.Sleeping.set(b, false); b.sleepThreshold = -1; });
        }
        function triggerExplosion() {
            dom.misc.losContainer.classList.add('hidden'); if(stirrer) { Matter.Composite.remove(engine.world, stirrer); stirrer = null; }
            Matter.Composite.remove(engine.world, Matter.Composite.allBodies(engine.world).filter(b => b.label==='wall'));
            state.view.targetZoom = 0.4;
            Matter.Composite.allBodies(engine.world).forEach(b => { if(!b.isStatic) Matter.Body.applyForce(b, b.position, { x: (Math.random()-0.5)*1.5, y: -2.5-Math.random()*2 }); });
            setTimeout(showEnd, 4000);
        }
        function showEnd() {
            state.game.active = false; stopPhysics();
            dom.views.spiel.classList.add('hidden'); dom.views.ende.classList.remove('hidden'); dom.views.ende.classList.add('flex');
            dom.stats.resRight.textContent = state.game.richtig;
            const d = Date.now() - state.game.startTimeGlobal; dom.stats.resTime.textContent = `${Math.floor(d/60000).toString().padStart(2,'0')}:${Math.floor((d%60000)/1000).toString().padStart(2,'0')}`;
        }
        function saveSettings() {
            const checked = dom.inputs.container.querySelectorAll('input:checked');
            const d = { heftIndex: dom.inputs.heftSelect.value, buchstaben: Array.from(checked).map(c => c.value), minSilben: parseInt(dom.inputs.min.value), maxSilben: parseInt(dom.inputs.max.value), mode: state.settings.mode, targetValue: state.settings.mode === 'count' ? parseInt(dom.inputs.valCount.value) : parseInt(dom.inputs.valTime.value), farben: dom.inputs.color.checked, abstand: dom.inputs.gap.checked };
            if (d.minSilben > d.maxSilben) d.minSilben = d.maxSilben;
            state.settings = d; try { localStorage.setItem('leseAppConf', JSON.stringify(d)); } catch(e) {}
        }
        function ladeEinstellungen() {
            let d = { heftIndex: 1, buchstaben: ['A','M','O','L','I'], minSilben: 1, maxSilben: 2, mode: 'count', targetValue: 10, farben: true, abstand: false };
            try { const s = localStorage.getItem('leseAppConf'); if(s) { const p = JSON.parse(s); d = {...d, ...p}; } } catch(e){}
            state.settings = d; dom.inputs.min.value = d.minSilben; dom.inputs.max.value = d.maxSilben; dom.inputs.color.checked = d.farben; dom.inputs.gap.checked = d.abstand; dom.inputs.heftSelect.value = d.heftIndex || 1;
            setMode(d.mode); if(d.mode==='count') dom.inputs.valCount.value = d.targetValue; else dom.inputs.valTime.value = d.targetValue;
            updateBuchstabenUI(parseInt(d.heftIndex || 1), d.buchstaben);
            updateLabels();
        }
        function handleInteractionStart(e) {
            if(!state.game.finished || state.settings.mode !== 'time') return;
            const x = e.touches ? e.touches[0].clientX : e.clientX; const y = e.touches ? e.touches[0].clientY : e.clientY;
            const clicked = Matter.Query.point(Matter.Composite.allBodies(world), {x, y});
            let removed = false;
            clicked.forEach(b => { if(!b.isStatic && b.label!=='wall') { Matter.Composite.remove(world, b); createConfetti(b.position.x, b.position.y, b.render.fillStyle); removed=true; } });
            if(removed && Matter.Composite.allBodies(world).filter(b=>!b.isStatic && b.label!=='wall').length===0) setTimeout(showEnd, 1000);
        }
        function createConfetti(x, y, c) {
            for(let i=0; i<20; i++) { const p = Matter.Bodies.circle(x, y, 4, { render: { fillStyle: c }, frictionAir: 0.02, restitution: 0.6 }); Matter.Body.setVelocity(p, { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 }); Matter.Composite.add(world, p); setTimeout(() => { if(world) Matter.Composite.remove(world, p); }, 2000); }
        }
        document.addEventListener('mousedown', handleInteractionStart); document.addEventListener('touchstart', handleInteractionStart, {passive: false});
    </script>
</body>
</html>


