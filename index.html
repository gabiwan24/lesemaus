<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Lese-Lern-App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playwrite+DE+Grund:wght@100..400&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Playwrite DE Grund', cursive;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            background-color: #f9fafb;
        }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }

        .animate-pop-in {
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        
        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }

        .card-shadow {
            box-shadow: 0 4px 0 rgba(0,0,0,0.15), 0 8px 16px rgba(0,0,0,0.1);
        }

        #swipe-feedback-bg {
            transition: background-color 0.15s ease-out;
            will-change: background-color;
        }

        .fade-out {
            animation: fadeOut 0.5s ease-out forwards;
        }
        @keyframes fadeOut {
            from { opacity: 1; visibility: visible; }
            to { opacity: 0; visibility: hidden; }
        }
    </style>
</head>
<body class="w-screen h-[100dvh] overflow-hidden flex flex-col select-none">

    <div id="intro-screen" class="fixed inset-0 z-[100] bg-white flex items-center justify-center transition-opacity duration-500">
        <h1 class="text-5xl md:text-7xl font-bold text-blue-600 animate-bounce">Lesemaus</h1>
    </div>

    <div id="swipe-feedback-bg" class="absolute inset-0 z-0 pointer-events-none"></div>

    <div id="app" class="relative w-full h-full z-10 flex flex-col hidden opacity-0 transition-opacity duration-500">

        <!-- 1. EINSTELLUNGEN -->
        <div id="startbildschirm" class="flex flex-col h-full p-3 bg-white z-50 relative">
            <h1 class="text-2xl font-bold text-center text-blue-600 mb-2 mt-1 shrink-0">Lese-Training</h1>

            <div class="flex-grow flex flex-col gap-2 overflow-hidden">
                <fieldset class="border border-gray-200 rounded-xl p-2 flex flex-col min-h-0 shrink">
                    <legend class="text-sm font-semibold px-2 text-gray-500">Gelernte Buchstaben:</legend>
                    <div class="overflow-y-auto px-1">
                        <div id="buchstaben-container" class="grid grid-cols-5 sm:grid-cols-8 gap-1.5 pb-1"></div>
                    </div>
                </fieldset>

                <fieldset class="border border-gray-200 rounded-xl p-2 shrink-0">
                    <legend class="text-sm font-semibold px-2 text-gray-500">Optionen:</legend>
                    <div class="grid grid-cols-3 gap-2 mb-2">
                        <div>
                            <label class="block text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-0.5 text-center">Min</label>
                            <input type="number" id="min-silben" value="1" min="1" max="5" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-gray-50 text-lg font-bold">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-0.5 text-center">Max</label>
                            <input type="number" id="max-silben" value="2" min="1" max="5" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-gray-50 text-lg font-bold">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-0.5 text-center">Wörter</label>
                            <input type="number" id="woerter-pro-runde" value="10" min="1" max="50" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-gray-50 text-lg font-bold">
                        </div>
                    </div>
                    <div class="flex justify-between gap-2">
                        <div class="flex-1 bg-gray-50 p-1.5 rounded-lg flex items-center justify-center gap-2 border border-gray-100">
                            <input id="silben-faerben" type="checkbox" checked class="h-4 w-4 text-blue-600 rounded">
                            <label for="silben-faerben" class="text-xs font-medium text-gray-600">Bunt</label>
                        </div>
                        <div class="flex-1 bg-gray-50 p-1.5 rounded-lg flex items-center justify-center gap-2 border border-gray-100">
                            <input id="silben-abstand" type="checkbox" class="h-4 w-4 text-blue-600 rounded">
                            <label for="silben-abstand" class="text-xs font-medium text-gray-600">Abstand</label>
                        </div>
                    </div>
                </fieldset>
            </div>

            <div class="shrink-0 pt-3 pb-2 safe-area-pb">
                <button id="start-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-3.5 rounded-xl shadow-lg active:scale-95 transition-transform">
                    Start!
                </button>
            </div>
        </div>

        <!-- 2. SPIELFELD -->
        <div id="spiel" class="hidden w-full h-full relative flex flex-col">
            <div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-start z-50 pointer-events-none">
                <div id="fortschritt-anzeige" class="text-gray-500 font-bold text-sm bg-white/90 backdrop-blur px-4 py-2 rounded-full shadow-sm border border-gray-100">
                    Wort <span id="aktuelles-wort-nr">1</span> / <span id="max-woerter-nr">10</span>
                </div>
                <button id="einstellungen-button" class="text-gray-400 hover:text-blue-600 bg-white/90 backdrop-blur p-2 rounded-full shadow-sm border border-gray-100 pointer-events-auto active:scale-90 transition-transform">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                </button>
            </div>

            <div id="2d-canvas-container" class="absolute inset-0 z-0 w-full h-full"></div>

            <div class="absolute inset-0 z-30 flex items-center justify-center pointer-events-none p-4 pb-20">
                <div id="card-swipe-layer" class="w-full max-w-xs aspect-[3/2] pointer-events-auto cursor-grab active:cursor-grabbing touch-none select-none will-change-transform relative">
                    <div id="card-content-layer" class="w-full h-full bg-white rounded-3xl card-shadow border border-gray-200 flex items-center justify-center relative overflow-hidden bg-white select-none transition-colors duration-150">
                        <div id="wort-anzeige-container" class="w-full h-full flex items-center justify-center p-4 relative z-10 pointer-events-none">
                            <span id="wort-anzeige" class="font-bold whitespace-nowrap select-none text-gray-800 leading-none"></span>
                        </div>
                        <div id="card-overlay" class="absolute inset-0 z-20 flex items-center justify-center opacity-0 transition-opacity duration-150 bg-transparent pointer-events-none"></div>
                    </div>
                </div>
            </div>

            <div id="los-button-container" class="hidden absolute bottom-10 left-0 right-0 flex justify-center z-50 pointer-events-none">
                <button id="los-button" class="pointer-events-auto bg-blue-600 hover:bg-blue-700 text-white font-bold text-3xl py-3 px-12 rounded-full shadow-xl transition-transform duration-150 hover:scale-105 active:scale-95 animate-bounce">
                    Los!
                </button>
            </div>
        </div>

        <!-- 3. AUSWERTUNG -->
        <div id="auswertung" class="hidden absolute inset-0 z-[60] bg-white flex flex-col justify-center items-center p-6">
            <h2 class="text-5xl font-bold text-blue-600 mb-8 drop-shadow-sm">Super!</h2>
            <div id="sterne-anzeige" class="text-7xl text-yellow-400 mb-10 flex gap-2 drop-shadow-md"></div>
            <div class="bg-gray-50 p-6 rounded-2xl border border-gray-100 mb-12 w-full max-w-xs text-center">
                <p class="text-gray-500 text-lg mb-1">Ergebnis</p>
                <p class="text-3xl font-bold text-gray-800">
                    <span id="richtige-woerter-anzahl" class="text-green-600">0</span> / <span id="max-woerter-anzahl">10</span>
                </p>
            </div>
            <button id="zurueck-button" class="w-full max-w-xs bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-4 rounded-xl shadow-lg active:scale-95 transition-transform">
                Nochmal spielen
            </button>
        </div>

    </div>

    <script>
        // --- DATEN ---
        const ALLE_BUCHSTABEN = ['A', 'E', 'I', 'O', 'U', 'Ä', 'Ö', 'Ü', 'Ei', 'Ai', 'Eu', 'Au', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z', 'Ch', 'Sch', 'Ck'];
        const VOKALE_LISTE = ['A', 'E', 'I', 'O', 'U', 'Ä', 'Ö', 'Ü'];
        const DIPHTHONGE_LISTE = ['Ei', 'Ai', 'Eu', 'Au'];
        const RAINBOW_COLORS = ['#9C4F96', '#FF6355', '#FBA949', '#FAE442', '#8BD448', '#2AA8F2'];
        
        const WOERTERBUCH = [
            ['O', 'ma'], ['O', 'pa'], ['Ma', 'ma'], ['Pa', 'pa'], ['La', 'ma'], ['Li', 'mo'], ['Li', 'la'], ['Lo', 'la'], ['Ma', 'li'], ['Mi', 'mi'], ['E', 'sel'], ['Na', 'se'], ['Ro', 'se'], ['So', 'fa'], ['Sa', 'la', 'mi'], ['Sa', 'lat'], ['To', 'ma', 'te'], ['Me', 'lo', 'ne'], ['Ba', 'na', 'ne'], ['Am', 'pel'], ['Ap', 'fel'], ['Son', 'ne'], ['Mon', 'd'], ['Ste', 'rn'], ['Ti', 'sch'], ['Stu', 'hl'], ['Nu', 'del'], ['Pi', 'rat'], ['Ra', 'ke', 'te'], ['Hu', 'nd'], ['Ka', 'tze'], ['Maus'], ['Haus'], ['Baum'], ['Ball'], ['Buch'], ['Fi', 'sch'], ['Vo', 'gel'], ['Blu', 'me'], ['Wol', 'ke'], ['Re', 'gen'], ['Schnee'], ['Eis'], ['Wa', 'l'], ['Zebra'], ['Lö', 'we'], ['Ti', 'ger'], ['En', 'te'], ['Gan', 's'], ['Huh', 'n'], ['Kuh'], ['Scha', 'f'], ['Pferd'], ['Au', 'to'], ['Bus'], ['Zug'], ['Schiff'], ['See'], ['Tee'], ['Fee'], ['Klee'], ['Pa', 'ket'], ['Ka', 'mel'], ['In', 'sel'], ['Pin', 'sel']
        ];

        // --- STATE ---
        const state = {
            settings: { buchstaben: [], minSilben: 1, maxSilben: 2, woerter: 10, farben: true, abstand: false },
            game: { 
                runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: false, finished: false,
                letterStats: {},
                wordStartTime: 0
            },
            view: { zoom: 1, targetZoom: 1 }
        };

        // --- DOM ---
        const dom = {
            intro: document.getElementById('intro-screen'),
            app: document.getElementById('app'),
            views: { start: document.getElementById('startbildschirm'), spiel: document.getElementById('spiel'), ende: document.getElementById('auswertung') },
            inputs: { container: document.getElementById('buchstaben-container'), min: document.getElementById('min-silben'), max: document.getElementById('max-silben'), woerter: document.getElementById('woerter-pro-runde'), color: document.getElementById('silben-faerben'), gap: document.getElementById('silben-abstand') },
            btns: { start: document.getElementById('start-button'), settings: document.getElementById('einstellungen-button'), back: document.getElementById('zurueck-button'), los: document.getElementById('los-button') },
            card: { swipe: document.getElementById('card-swipe-layer'), content: document.getElementById('card-content-layer'), textContainer: document.getElementById('wort-anzeige-container'), text: document.getElementById('wort-anzeige'), overlay: document.getElementById('card-overlay'), bg: document.getElementById('swipe-feedback-bg') },
            stats: { curr: document.getElementById('aktuelles-wort-nr'), max: document.getElementById('max-woerter-nr'), stars: document.getElementById('sterne-anzeige'), resRight: document.getElementById('richtige-woerter-anzahl'), resMax: document.getElementById('max-woerter-anzahl') },
            misc: { losContainer: document.getElementById('los-button-container') }
        };

        // --- PHYSICS ---
        let engine, render, runner, stirrer, physicsActive = false;

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            try {
                initUI();
                ladeEinstellungen();
                initSwipeLogic();
                startAppSequence();
                
                dom.btns.start.onclick = startGame;
                dom.btns.settings.onclick = showStart;
                dom.btns.back.onclick = showStart;
                dom.btns.los.onclick = triggerExplosion;
                
                window.addEventListener('resize', () => { if(physicsActive) resizePhysics(); adjustFontSize(); });
                document.addEventListener('mousemove', moveStirrer);
                document.addEventListener('touchmove', moveStirrer, {passive: false});
                document.addEventListener('touchstart', moveStirrer, {passive: false});
                document.addEventListener('mousedown', moveStirrer);
            } catch (e) {
                console.error("Init Error:", e);
                dom.intro.style.display = 'none';
                dom.app.classList.remove('hidden');
                dom.app.style.opacity = '1';
                dom.views.start.classList.remove('hidden');
                dom.views.start.classList.add('flex');
            }
        });

        function initUI() {
            dom.inputs.container.innerHTML = ALLE_BUCHSTABEN.map(b => `
                <div class="flex items-center justify-center">
                    <input type="checkbox" id="cb-${b}" value="${b}" class="peer hidden">
                    <label for="cb-${b}" class="w-full text-center py-2 border border-gray-200 rounded-lg cursor-pointer text-gray-600 font-bold select-none transition-colors peer-checked:border-blue-500 peer-checked:bg-blue-50 peer-checked:text-blue-600 text-sm sm:text-base bg-white">${b}</label>
                </div>
            `).join('');
        }

        function startAppSequence() {
            setTimeout(() => {
                dom.intro.classList.add('fade-out');
                setTimeout(() => {
                    dom.intro.style.display = 'none';
                    dom.app.classList.remove('hidden');
                    void dom.app.offsetWidth;
                    dom.app.style.opacity = '1';
                    
                    dom.views.start.classList.remove('hidden');
                    dom.views.start.classList.add('flex');
                }, 500);
            }, 1500);
            
            setTimeout(() => {
                if(dom.intro.style.display !== 'none') {
                    dom.intro.style.display = 'none';
                    dom.app.classList.remove('hidden');
                    dom.app.style.opacity = '1';
                    dom.views.start.classList.remove('hidden');
                    dom.views.start.classList.add('flex');
                }
            }, 3000);
        }

        // --- GAME LOGIC ---
        function startGame() {
            saveSettings();
            state.game = { 
                runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: true, finished: false, letterStats: {}
            };
            state.view = { zoom: 1, targetZoom: 1 };
            state.settings.buchstaben.forEach(b => state.game.letterStats[b] = 0);
            
            dom.views.start.classList.add('hidden');
            dom.views.ende.classList.add('hidden');
            dom.views.spiel.classList.remove('hidden');
            dom.misc.losContainer.classList.add('hidden');
            dom.card.swipe.classList.remove('hidden');
            
            startPhysics();
            nextCard(true);
        }

        function showStart() {
            state.game.active = false;
            stopPhysics();
            dom.views.spiel.classList.add('hidden');
            dom.views.ende.classList.add('hidden');
            dom.views.start.classList.remove('hidden');
            dom.views.start.classList.add('flex');
            dom.card.content.style.backgroundColor = 'white';
        }

        function nextCard(first = false) {
            if (state.game.runde >= state.settings.woerter) {
                prepareEndPhase();
                return;
            }

            dom.stats.curr.textContent = state.game.runde + 1;
            dom.stats.max.textContent = state.settings.woerter;

            let wort = selectWordPriority();
            let versuche = 0;
            while (state.game.history.has(wort.join('')) && versuche < 20) {
                wort = selectWordPriority();
                versuche++;
            }
            state.game.history.add(wort.join(''));
            
            const fullString = wort.join('').toUpperCase();
            state.settings.buchstaben.forEach(token => {
                if (fullString.includes(token.toUpperCase())) {
                    state.game.letterStats[token] = (state.game.letterStats[token] || 0) + 1;
                }
            });

            dom.card.text.innerHTML = '';
            wort.forEach((silbe, i) => {
                const span = document.createElement('span');
                let text = silbe.toLowerCase();
                if (i === 0 && Math.random() < 0.8) text = text.charAt(0).toUpperCase() + text.slice(1);
                span.textContent = text;
                if (state.settings.farben) span.className = i % 2 === 0 ? 'text-blue-600' : 'text-red-600';
                if (state.settings.abstand && i < wort.length - 1) span.style.marginRight = '0.2em';
                dom.card.text.appendChild(span);
            });

            adjustFontSize();

            const card = dom.card.swipe;
            card.style.transition = 'none';
            card.style.transform = 'translate(0,0) rotate(0) scale(0.8)';
            card.style.opacity = '0';
            dom.card.overlay.style.opacity = '0';
            dom.card.content.style.backgroundColor = 'white';
            
            requestAnimationFrame(() => {
                card.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                card.style.transform = 'translate(0,0) rotate(0) scale(1)';
                card.style.opacity = '1';
                
                // Start Time
                state.game.wordStartTime = Date.now();
            });
        }

        // --- SMART WORD SELECTION ---
        function selectWordPriority() {
            const allowedCharsFlat = new Set();
            state.settings.buchstaben.forEach(token => {
                token.toUpperCase().split('').forEach(char => allowedCharsFlat.add(char));
            });

            const realCandidates = WOERTERBUCH.filter(silben => {
                if(silben.length < state.settings.minSilben || silben.length > state.settings.maxSilben) return false;
                const fullWord = silben.join('').toUpperCase();
                for(const char of fullWord) {
                    if(!allowedCharsFlat.has(char)) return false;
                }
                return true;
            });

            const scoreWord = (silbenArray) => {
                const wordStr = silbenArray.join('').toUpperCase();
                let score = 0;
                state.settings.buchstaben.forEach(token => {
                    if(wordStr.includes(token.toUpperCase())) {
                        const count = state.game.letterStats[token] || 0;
                        score += (count === 0 ? 100 : 1 / (count + 1));
                    }
                });
                return score;
            };

            if (realCandidates.length > 0) {
                const unusedReal = realCandidates.filter(w => !state.game.history.has(w.join('')));
                const pool = unusedReal.length > 0 ? unusedReal : realCandidates;
                pool.sort((a, b) => scoreWord(b) - scoreWord(a));
                const topK = Math.min(pool.length, 3);
                return pool[Math.floor(Math.random() * topK)];
            }

            const targetLen = determineTargetLength();
            return generateBalancedFantasyWord(targetLen);
        }

        // 75% Wahrscheinlichkeit für maximale Silbenlänge (wenn möglich)
        function determineTargetLength() {
            const min = state.settings.minSilben;
            const max = state.settings.maxSilben;
            if (min === max) return max;
            return Math.random() < 0.75 ? max : Math.floor(Math.random() * (max - 1 - min + 1)) + min;
        }

        function generateBalancedFantasyWord(length) {
            const res = [];
            const v = state.settings.buchstaben.filter(b => VOKALE_LISTE.includes(b));
            const k = state.settings.buchstaben.filter(b => !VOKALE_LISTE.includes(b) && !DIPHTHONGE_LISTE.includes(b));
            const d = state.settings.buchstaben.filter(b => DIPHTHONGE_LISTE.includes(b));
            
            if (v.length === 0 && d.length === 0) return ["A".repeat(length).split('')]; 

            const pickWeighted = (pool, exclude) => {
                if (pool.length === 0) return '';
                let candidates = pool;
                if (exclude && pool.length > 1) candidates = pool.filter(c => c !== exclude);
                
                let minUsage = Infinity;
                candidates.forEach(char => {
                    const u = state.game.letterStats[char] || 0;
                    if (u < minUsage) minUsage = u;
                });
                const best = candidates.filter(char => (state.game.letterStats[char] || 0) === minUsage);
                return best[Math.floor(Math.random() * best.length)];
            };

            let lastConsonant = '';
            let lastVowel = '';

            for(let i=0; i<length; i++) {
                let s = '';
                let attempts = 0;
                let valid = false;

                do {
                    let type = 'KV';
                    if(Math.random() < 0.1 && i === 0) type = 'V'; 
                    if (i > 0 && VOKALE_LISTE.includes(res[i-1].slice(-1).toUpperCase())) type = 'KV';

                    s = '';
                    let curC = '', curV = '';

                    if(type === 'KV' && k.length > 0) {
                        curC = pickWeighted(k, lastConsonant);
                        s += curC;
                    }
                    
                    if(d.length > 0 && Math.random() < 0.2) {
                        s += pickWeighted(d, lastVowel); // Treat diphthong like vowel for exclusion
                    } else if(v.length > 0) {
                        curV = pickWeighted(v, lastVowel);
                        s += curV;
                    }
                    
                    valid = true;
                    if (length >= 3 && i > 0 && s === res[i-1]) valid = false;
                    if (length >= 4 && i > 1 && s === res[i-2]) valid = false;
                    if (i > 0 && res[i-1].slice(-1).toLowerCase() === s.charAt(0).toLowerCase()) valid = false;

                    if (valid) {
                        if (curC) lastConsonant = curC;
                        if (curV) lastVowel = curV;
                    }
                    attempts++;
                } while (!valid && attempts < 20);
                res.push(s);
            }
            return res;
        }

        function handleResult(success) {
            if (success) {
                state.game.richtig++;
                const duration = Date.now() - state.game.wordStartTime;
                let factor = 1.0;
                if (duration < 2000) factor = 2.0; 
                else if (duration > 5000) factor = 0.5;
                spawnParticles(factor);
            }
            state.game.runde++;
            setTimeout(() => nextCard(), 300);
        }

        // --- SWIPE ---
        function initSwipeLogic() {
            let startX = 0, isDragging = false;
            const card = dom.card.swipe;
            const content = dom.card.content;
            
            const start = (x) => {
                if (state.game.finished) return;
                startX = x;
                isDragging = true;
                card.style.transition = 'none';
            };
            
            const move = (x) => {
                if (!isDragging) return;
                const diff = x - startX;
                card.style.transform = `translate(${diff}px, 0) rotate(${diff * 0.05}deg)`;
                
                const opacity = Math.min(Math.abs(diff) / 150, 0.3);
                if (diff > 0) {
                    content.style.backgroundColor = `rgba(34, 197, 94, ${0.1 + opacity * 0.5})`; // Grünlich
                    dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-green-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M5 13l4 4L19 7"></path></svg>`;
                } else {
                    content.style.backgroundColor = `rgba(107, 114, 128, ${0.1 + opacity * 0.5})`;
                    dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-gray-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M6 18L18 6M6 6l12 12"></path></svg>`;
                }
                dom.card.overlay.style.opacity = Math.min(Math.abs(diff) / 100, 1);
            };
            
            const end = (x) => {
                if (!isDragging) return;
                isDragging = false;
                const diff = x - startX;
                
                if (Math.abs(diff) > 100) {
                    const dir = diff > 0 ? 1 : -1;
                    card.style.transition = 'transform 0.2s ease-out';
                    card.style.transform = `translate(${dir * 500}px, 0) rotate(${dir * 45}deg)`;
                    handleResult(dir === 1);
                } else {
                    card.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                    card.style.transform = 'translate(0,0) rotate(0)';
                    content.style.backgroundColor = 'white';
                    dom.card.overlay.style.opacity = '0';
                }
            };

            card.addEventListener('touchstart', e => start(e.touches[0].clientX));
            window.addEventListener('touchmove', e => move(e.touches[0].clientX));
            window.addEventListener('touchend', e => end(e.changedTouches[0].clientX));
            card.addEventListener('mousedown', e => start(e.clientX));
            window.addEventListener('mousemove', e => move(e.clientX));
            window.addEventListener('mouseup', e => end(e.clientX));
        }

        // --- PHYSICS ---
        function startPhysics() {
            stopPhysics();
            const container = document.getElementById('2d-canvas-container');
            engine = Matter.Engine.create({ enableSleeping: true });
            world = engine.world;
            
            render = Matter.Render.create({
                element: container,
                engine: engine,
                options: { width: container.clientWidth, height: container.clientHeight, wireframes: false, background: 'transparent' }
            });
            
            createWalls(container.clientWidth, container.clientHeight);
            
            (function loop() {
                if (!engine) return;
                window.requestAnimationFrame(loop);
                
                // Update Physics
                Matter.Engine.update(engine, 1000/60);
                
                // Custom Render mit Zoom
                const ctx = render.context;
                const w = render.canvas.width;
                const h = render.canvas.height;

                ctx.clearRect(0, 0, w, h);
                
                ctx.save();
                // Zoom Logic: Center at (width/2, height/2)
                // Zoom interpolation
                state.view.zoom += (state.view.targetZoom - state.view.zoom) * 0.05;
                
                ctx.translate(w/2, h/2);
                ctx.scale(state.view.zoom, state.view.zoom);
                ctx.translate(-w/2, -h/2);

                Matter.Composite.allBodies(world).forEach(b => {
                    if (b.label === 'wall' || b.label === 'stirrer') return;
                    ctx.beginPath();
                    ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, 2*Math.PI);
                    ctx.fillStyle = b.render.fillStyle;
                    ctx.fill();
                });
                ctx.restore();
            })();
            physicsActive = true;
        }

        function stopPhysics() {
            engine = null; render = null; stirrer = null; physicsActive = false;
            document.getElementById('2d-canvas-container').innerHTML = '';
        }

        function resizePhysics() {
            if(!render) return;
            const container = document.getElementById('2d-canvas-container');
            render.canvas.width = container.clientWidth;
            render.canvas.height = container.clientHeight;
            createWalls(container.clientWidth, container.clientHeight);
        }

        function createWalls(w, h) {
            if(!world) return;
            Matter.Composite.clear(world, false, true); 
            const oldWalls = Matter.Composite.allBodies(world).filter(b => b.label === 'wall');
            Matter.Composite.remove(world, oldWalls);
            const th = 200;
            const wallOpts = { isStatic: true, label: 'wall', friction: 1, restitution: 0 };
            Matter.Composite.add(world, [
                Matter.Bodies.rectangle(w/2, h + th/2, w + 200, th, wallOpts), 
                Matter.Bodies.rectangle(-th/2, h/2, th, h*2, wallOpts), 
                Matter.Bodies.rectangle(w + th/2, h/2, th, h*2, wallOpts) 
            ]);
        }

        function spawnParticles(factor = 1.0) {
            if(!engine) return;
            const w = render.canvas.width;
            const h = render.canvas.height;
            
            // --- KORREKTUR: Dynamische Größe & Anzahl für Füllung ---
            let baseRadius = Math.min(Math.max(w * 0.015, 5), 15); 

            // Anzahl
            const baseCount = 30; 
            let count = Math.floor(baseCount * factor);
            if (count > 100) count = 100; 
            if (count < 10) count = 10;

            const color = RAINBOW_COLORS[state.game.colorIndex];
            state.game.colorIndex = (state.game.colorIndex + 1) % RAINBOW_COLORS.length;

            for(let i=0; i<count; i++) {
                // Varianz in der Größe: +/- 40%
                const r = baseRadius * (0.6 + Math.random() * 0.8);

                const x = Math.random() * w * 0.8 + w * 0.1;
                const y = -Math.random() * 300 - 50;
                const body = Matter.Bodies.circle(x, y, r, {
                    restitution: 0.1, friction: 0.5, frictionAir: 0.05, density: 0.04,
                    render: { fillStyle: color }
                });
                Matter.Composite.add(world, body);
            }
        }

        // --- MISC ---
        function adjustFontSize() {
            const el = dom.card.text;
            const parent = dom.card.textContainer;
            let size = 4;
            el.style.fontSize = `${size}rem`;
            while ((el.scrollWidth > parent.clientWidth || el.scrollHeight > parent.clientHeight) && size > 1) {
                size -= 0.2;
                el.style.fontSize = `${size}rem`;
            }
        }

        function moveStirrer(e) {
            if (!state.game.finished || dom.misc.losContainer.classList.contains('hidden')) return;
            if(e.type === 'touchmove') e.preventDefault();
            
            let x, y;
            if (e.type.startsWith('touch')) {
                 x = e.touches[0].clientX;
                 y = e.touches[0].clientY;
            } else {
                 x = e.clientX;
                 y = e.clientY;
            }
            
            if (!stirrer && engine) {
                stirrer = Matter.Bodies.circle(x, y, 80, { isStatic: true, label: 'stirrer' });
                Matter.Composite.add(engine.world, stirrer);
            } else if (stirrer) {
                Matter.Body.setPosition(stirrer, {x, y});
            }
        }

        function prepareEndPhase() {
            state.game.finished = true;
            dom.card.swipe.classList.add('hidden');
            dom.misc.losContainer.classList.remove('hidden');
            if(world) {
                Matter.Composite.allBodies(world).forEach(b => {
                    Matter.Sleeping.set(b, false);
                    b.sleepThreshold = -1; 
                });
            }
        }

        function triggerExplosion() {
            dom.misc.losContainer.classList.add('hidden');
            if(stirrer) { Matter.Composite.remove(engine.world, stirrer); stirrer = null; }
            
            // 1. Wände weg
            const walls = Matter.Composite.allBodies(engine.world).filter(b => b.label === 'wall');
            Matter.Composite.remove(engine.world, walls);

            // 2. Zoom Out
            state.view.targetZoom = 0.4;

            // 3. Massive Kraft mit hoher Varianz
            Matter.Composite.allBodies(engine.world).forEach(b => {
                if(!b.isStatic) {
                    Matter.Sleeping.set(b, false);
                    const dirX = (Math.random() - 0.5) * 3.0; 
                    // Kraft abhängig von Masse (0.05 * mass = Grundbeschleunigung) * Faktor
                    // Hier: 5x bis 15x so stark wie normal
                    const forceMagnitude = 0.05 * b.mass * (5 + Math.random() * 10.0); 

                    Matter.Body.applyForce(b, b.position, { 
                        x: dirX * forceMagnitude * 0.1, 
                        y: -1 * forceMagnitude 
                    });
                    
                    Matter.Body.setAngularVelocity(b, (Math.random() - 0.5) * 0.5);
                }
            });
            setTimeout(showEnd, 4000); 
        }

        function showEnd() {
            state.game.active = false;
            stopPhysics();
            dom.views.spiel.classList.add('hidden');
            dom.views.ende.classList.remove('hidden');
            dom.views.ende.classList.add('flex');
            
            dom.stats.resRight.textContent = state.game.richtig;
            dom.stats.resMax.textContent = state.settings.woerter;
            
            const pct = state.game.richtig / state.settings.woerter;
            let stars = 1; if(pct > 0.4) stars = 2; if(pct > 0.6) stars = 3; if(pct > 0.8) stars = 4; if(pct > 0.95) stars = 5;
            dom.stats.stars.innerHTML = Array(5).fill(0).map((_, i) => `<span class="${i < stars ? 'text-yellow-400' : 'text-gray-200'}">★</span>`).join('');
        }

        function saveSettings() {
            const checked = dom.inputs.container.querySelectorAll('input:checked');
            const d = {
                buchstaben: Array.from(checked).map(c => c.value),
                minSilben: parseInt(dom.inputs.min.value), 
                maxSilben: parseInt(dom.inputs.max.value), 
                woerter: parseInt(dom.inputs.woerter.value),
                farben: dom.inputs.color.checked, 
                abstand: dom.inputs.gap.checked
            };
            if (d.minSilben > d.maxSilben) d.minSilben = d.maxSilben;
            state.settings = d;
            try {
                localStorage.setItem('leseAppConf', JSON.stringify(d));
            } catch(e) {}
        }

        function ladeEinstellungen() {
            let d = { buchstaben: ['A','M','O','L','I'], minSilben: 1, maxSilben: 2, woerter: 10, farben: true, abstand: false };
            try { 
                const s = localStorage.getItem('leseAppConf'); 
                if(s) {
                    const parsed = JSON.parse(s);
                    d = {...d, ...parsed};
                    if (!Array.isArray(d.buchstaben)) d.buchstaben = ['A','M','O','L','I'];
                }
            } catch(e){
                localStorage.removeItem('leseAppConf');
            }
            state.settings = d;
            dom.inputs.min.value = d.minSilben; dom.inputs.max.value = d.maxSilben; dom.inputs.woerter.value = d.woerter;
            dom.inputs.color.checked = d.farben; dom.inputs.gap.checked = d.abstand;
            
            dom.inputs.container.querySelectorAll('input').forEach(cb => {
                cb.checked = d.buchstaben.includes(cb.value);
            });
        }
    </script>
</body>
</html>


