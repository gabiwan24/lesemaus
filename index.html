<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Lese-Lern-App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playwrite+DE+Grund:wght@100..400&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Playwrite DE Grund', cursive;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            background-color: #f9fafb;
        }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }

        .animate-pop-in { animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes popIn { 0% { opacity: 0; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }

        .card-shadow { box-shadow: 0 4px 0 rgba(0,0,0,0.15), 0 8px 16px rgba(0,0,0,0.1); }

        #swipe-feedback-bg { transition: background-color 0.15s ease-out; will-change: background-color; }
        .fade-out { animation: fadeOut 0.5s ease-out forwards; }
        @keyframes fadeOut { from { opacity: 1; visibility: visible; } to { opacity: 0; visibility: hidden; } }

        /* Graustufen Filter f√ºr nicht erreichte Tiere */
        .grayscale-icon { filter: grayscale(100%); opacity: 0.3; transform: scale(0.8); }
        .active-animal { transform: scale(1.2); filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2)); }
    </style>
</head>
<body class="w-screen h-[100dvh] overflow-hidden flex flex-col select-none">

    <div id="intro-screen" class="fixed inset-0 z-[100] bg-white flex items-center justify-center transition-opacity duration-500">
        <h1 class="text-5xl md:text-7xl font-bold text-blue-600 animate-bounce">Lesemaus</h1>
    </div>

    <div id="swipe-feedback-bg" class="absolute inset-0 z-0 pointer-events-none"></div>

    <div id="app" class="relative w-full h-full z-10 flex flex-col hidden opacity-0 transition-opacity duration-500">

        <div id="startbildschirm" class="flex flex-col h-full p-3 bg-white z-50 relative">
            <h1 class="text-2xl font-bold text-center text-blue-600 mb-2 mt-1 shrink-0">Lese-Training</h1>

            <div class="flex-grow flex flex-col gap-2 overflow-hidden">
                
                <div class="shrink-0">
                    <label class="block text-xs font-bold text-gray-500 uppercase tracking-wider mb-2 px-1">1. Lernstand w√§hlen</label>
                    <div id="heft-buttons-container" class="flex flex-col gap-2">
                        </div>
                </div>

                <fieldset id="buchstaben-fieldset" class="border border-gray-200 rounded-xl p-2 flex flex-col min-h-0 shrink transition-all duration-300">
                    <legend class="text-sm font-semibold px-2 text-gray-500">2. Buchstaben im aktuellen Heft</legend>
                    <div class="overflow-y-auto px-1">
                        <div id="buchstaben-container" class="grid grid-cols-5 sm:grid-cols-8 gap-2 pb-1">
                            </div>
                    </div>
                </fieldset>

                <fieldset class="border border-gray-200 rounded-xl p-2 shrink-0">
                    <legend class="text-sm font-semibold px-2 text-gray-500">Optionen</legend>
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <div>
                            <label id="lbl-min" class="block text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-0.5 text-center whitespace-nowrap">Min 1 Silbe</label>
                            <input type="number" id="min-silben" value="1" min="1" max="5" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-gray-50 text-lg font-bold">
                        </div>
                        <div>
                            <label id="lbl-max" class="block text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-0.5 text-center whitespace-nowrap">Max 2 Silben</label>
                            <input type="number" id="max-silben" value="2" min="1" max="5" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-gray-50 text-lg font-bold">
                        </div>
                    </div>

                    <div class="mb-2">
                        <div class="flex rounded-lg overflow-hidden border border-gray-200 mb-2 bg-gray-50">
                            <button id="btn-mode-count" class="mode-btn flex-1 py-1.5 text-sm font-bold bg-blue-600 text-white transition-colors">Anzahl</button>
                            <button id="btn-mode-time" class="mode-btn flex-1 py-1.5 text-sm font-bold bg-transparent text-gray-600 transition-colors">Zeit</button>
                        </div>
                        
                        <div id="input-container-count" class="block">
                            <input type="number" id="woerter-pro-runde" value="10" min="1" max="50" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-white text-lg font-bold placeholder-gray-400" placeholder="Anzahl W√∂rter">
                        </div>
                        <div id="input-container-time" class="hidden">
                            <input type="number" id="zeit-limit" value="5" min="1" max="20" class="w-full text-center border-gray-300 rounded-lg py-1.5 bg-white text-lg font-bold placeholder-gray-400" placeholder="Minuten">
                        </div>
                    </div>
                    
                    <div class="flex justify-between gap-2">
                        <div class="flex-1 bg-gray-50 p-1.5 rounded-lg flex items-center justify-center gap-2 border border-gray-100 px-2">
                            <input id="silben-faerben" type="checkbox" checked class="h-5 w-5 text-blue-600 rounded flex-shrink-0">
                            <label for="silben-faerben" class="text-xs font-medium text-gray-600">Bunt</label>
                        </div>
                        <div class="flex-1 bg-gray-50 p-1.5 rounded-lg flex items-center justify-center gap-2 border border-gray-100 px-2">
                            <input id="silben-abstand" type="checkbox" class="h-5 w-5 text-blue-600 rounded flex-shrink-0">
                            <label for="silben-abstand" class="text-xs font-medium text-gray-600">Abstand</label>
                        </div>
                    </div>
                </fieldset>
            </div>

            <div class="shrink-0 pt-3 pb-2 safe-area-pb">
                <button id="start-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-3.5 rounded-xl shadow-lg active:scale-95 transition-transform">
                    Start!
                </button>
            </div>
        </div>

        <div id="spiel" class="hidden w-full h-full relative flex flex-col">
            <div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-start z-50 pointer-events-none">
                <div class="flex flex-col gap-2 pointer-events-auto items-start">
                    <button id="stop-button" class="hidden bg-red-100 text-red-600 hover:bg-red-200 font-bold text-xs px-3 py-2 rounded-full shadow-sm border border-red-200 mb-1 transition-all active:scale-95">
                        <span class="flex items-center gap-1"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z"/></svg> Beenden</span>
                    </button>
                    <div class="flex gap-2">
                        <div id="fortschritt-anzeige" class="text-blue-600 font-mono font-bold text-lg bg-white/90 backdrop-blur px-3 py-1 rounded-full shadow-sm border border-gray-100 flex items-center">
                            <span id="fortschritt-text">1 / 10</span>
                        </div>
                        <div id="timer-display" class="text-blue-600 font-mono font-bold text-lg bg-white/90 backdrop-blur px-3 py-1 rounded-full shadow-sm border border-gray-100 flex items-center">00:00</div>
                    </div>
                </div>
                <button id="einstellungen-button" class="text-gray-400 hover:text-blue-600 bg-white/90 backdrop-blur p-2 rounded-full shadow-sm border border-gray-100 pointer-events-auto active:scale-90 transition-transform">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                </button>
            </div>
            <div id="2d-canvas-container" class="absolute inset-0 z-0 w-full h-full"></div>
            <div class="absolute inset-0 z-30 flex items-center justify-center pointer-events-none p-4 pb-20">
                <div id="card-swipe-layer" class="w-full max-w-xs aspect-[3/2] pointer-events-auto cursor-grab active:cursor-grabbing touch-none select-none will-change-transform relative">
                    <div id="card-content-layer" class="w-full h-full bg-white rounded-3xl card-shadow border border-gray-200 flex items-center justify-center relative overflow-hidden bg-white select-none transition-colors duration-150">
                        <div id="wort-anzeige-container" class="w-full h-full flex items-center justify-center p-4 relative z-10 pointer-events-none">
                            <span id="wort-anzeige" class="font-bold whitespace-nowrap select-none text-gray-800 leading-none"></span>
                        </div>
                        <div id="card-overlay" class="absolute inset-0 z-20 flex items-center justify-center opacity-0 transition-opacity duration-150 bg-transparent pointer-events-none"></div>
                    </div>
                </div>
            </div>
            <div id="los-button-container" class="hidden absolute bottom-10 left-0 right-0 flex justify-center z-50 pointer-events-none">
                <button id="los-button" class="pointer-events-auto bg-blue-600 hover:bg-blue-700 text-white font-bold text-3xl py-3 px-12 rounded-full shadow-xl transition-transform duration-150 hover:scale-105 active:scale-95 animate-bounce">Los!</button>
            </div>
        </div>

        <div id="auswertung" class="hidden absolute inset-0 z-[60] bg-white flex flex-col justify-center items-center p-6">
            <h2 class="text-4xl font-bold text-blue-600 mb-6 drop-shadow-sm">Super!</h2>
            
            <div id="tier-leiter" class="flex flex-col-reverse items-center gap-2 mb-8 w-full max-w-xs">
                </div>

            <div class="bg-gray-50 p-4 rounded-2xl border border-gray-100 mb-8 w-full max-w-xs text-center">
                <p class="text-gray-500 text-sm mb-1">Ergebnis</p>
                <p class="text-2xl font-bold text-gray-800 mb-1"><span id="richtige-woerter-anzahl" class="text-green-600">0</span> richtig</p>
                <p class="text-base text-gray-500">Zeit: <span id="gesamt-zeit-anzeige" class="font-mono text-gray-700">00:00</span></p>
            </div>
            <button id="zurueck-button" class="w-full max-w-xs bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl py-4 rounded-xl shadow-lg active:scale-95 transition-transform">Nochmal spielen</button>
        </div>
    </div>

    <script>
        // --- DATEN & KONFIGURATION ---
        const HEFTE = [
            { name: "1", desc: "M, A, L, I, O, S...", buchstaben: ['M', 'A', 'L', 'I', 'O', 'S'] },
            { name: "2", desc: "E, N, D, U, P, K", buchstaben: ['E', 'N', 'D', 'U', 'P', 'K'] },
            { name: "3", desc: "H, T, R, F, W...", buchstaben: ['H', 'T', 'R', 'F', 'W', 'Ei', 'Au', 'Eu'] },
            { name: "4", desc: "B, G, J, Z, Ch...", buchstaben: ['B', 'G', 'J', 'Z', 'Ch', 'Sch', 'Ck', '√Ñ', '√ñ', '√ú', 'V', 'X', 'Y', 'Q'] }
        ];

        const ANIMALS = [
            { icon: 'üêå', wpm: 1 }, // Schnecke (< 5 W√∂rter/5min)
            { icon: 'üê¢', wpm: 2 }, // Schildkr√∂te (10 W√∂rter)
            { icon: 'üêá', wpm: 3 }, // Hase (15 W√∂rter)
            { icon: 'üêé', wpm: 4 }, // Pferd (20 W√∂rter)
            { icon: 'üêÜ', wpm: 5 }  // Gepard (> 25 W√∂rter)
        ];

        const VOKALE_LISTE = ['A', 'E', 'I', 'O', 'U', '√Ñ', '√ñ', '√ú'];
        const DIPHTHONGE_LISTE = ['Ei', 'Ai', 'Eu', 'Au'];
        const RAINBOW_COLORS = ['#9C4F96', '#FF6355', '#FBA949', '#FAE442', '#8BD448', '#2AA8F2'];
        
        const WOERTERBUCH = [
            ['O', 'ma'], ['O', 'pa'], ['Ma', 'ma'], ['Pa', 'pa'], ['La', 'ma'], ['Li', 'mo'], ['Li', 'la'], ['Lo', 'la'], ['Ma', 'li'], ['Mi', 'mi'], ['Sa', 'la', 'mi'], ['Sa', 'lat'], ['So', 'fa'], ['Li', 'sa'], ['Ali'],
            ['En', 'te'], ['E', 'sel'], ['Na', 'se'], ['No', 'te'], ['Nu', 'del'], ['Na', 'del'], ['Do', 'se'], ['Mon', 'd'], ['Un', 'd'], ['Hu', 'nd'], ['Ka', 'nu'], ['Pa', 'pa'], ['Pa', 'ket'], ['Pin', 'sel'], ['Pup', 'pe'], ['Lam', 'pe'], ['Am', 'pel'], ['Kin', 'd'], ['Ki', 'no'], ['Kis', 'te'], ['Klas', 'se'], ['Ka', 'me', 'l'], ['In', 'sel'], ['San', 'd'], ['Son', 'ne'], ['To', 'ma', 'te'], ['Me', 'lo', 'ne'], ['Ba', 'na', 'ne'], ['Man', 'tel'], ['Kap', 'pe'], ['Tas', 'se'], ['Nu', 'ss'], ['Ka', 'nu'],
            ['Hut'], ['Haus'], ['Baum'], ['Ball'], ['Buch'], ['Fi', 'sch'], ['Vo', 'gel'], ['Blu', 'me'], ['Wol', 'ke'], ['Re', 'gen'], ['Schnee'], ['Eis'], ['Wa', 'l'], ['Zeb', 'ra'], ['L√∂', 'we'], ['Ti', 'ger'], ['En', 'te'], ['Gans'], ['Huhn'], ['Kuh'], ['Scha', 'f'], ['Pferd'], ['Au', 'to'], ['Bus'], ['Zug'], ['Schiff'], ['See'], ['Tee'], ['Fee'], ['Klee']
        ];

        // --- STATE ---
        const state = {
            settings: { 
                heftIndex: 1, buchstaben: [], minSilben: 1, maxSilben: 2, 
                mode: 'count', targetValue: 10, farben: true, abstand: false 
            },
            game: { 
                runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: false, finished: false,
                letterStats: {}, wordStartTime: 0, startTimeGlobal: 0, timerInterval: null,
                realWordsPossible: []
            },
            view: { zoom: 1, targetZoom: 1 }
        };

        // --- DOM ---
        const dom = {
            intro: document.getElementById('intro-screen'), app: document.getElementById('app'),
            views: { start: document.getElementById('startbildschirm'), spiel: document.getElementById('spiel'), ende: document.getElementById('auswertung') },
            inputs: { heftContainer: document.getElementById('heft-buttons-container'), container: document.getElementById('buchstaben-container'), prevList: document.getElementById('prev-letters-list'), min: document.getElementById('min-silben'), max: document.getElementById('max-silben'), modeCount: document.getElementById('btn-mode-count'), modeTime: document.getElementById('btn-mode-time'), countInput: document.getElementById('input-container-count'), timeInput: document.getElementById('input-container-time'), valCount: document.getElementById('woerter-pro-runde'), valTime: document.getElementById('zeit-limit'), color: document.getElementById('silben-faerben'), gap: document.getElementById('silben-abstand'), lblMin: document.getElementById('lbl-min'), lblMax: document.getElementById('lbl-max') },
            btns: { start: document.getElementById('start-button'), settings: document.getElementById('einstellungen-button'), back: document.getElementById('zurueck-button'), los: document.getElementById('los-button'), stop: document.getElementById('stop-button') },
            card: { swipe: document.getElementById('card-swipe-layer'), content: document.getElementById('card-content-layer'), textContainer: document.getElementById('wort-anzeige-container'), text: document.getElementById('wort-anzeige'), overlay: document.getElementById('card-overlay'), bg: document.getElementById('swipe-feedback-bg') },
            stats: { progressText: document.getElementById('fortschritt-text'), timer: document.getElementById('timer-display'), resRight: document.getElementById('richtige-woerter-anzahl'), resTime: document.getElementById('gesamt-zeit-anzeige'), animals: document.getElementById('tier-leiter') },
            misc: { losContainer: document.getElementById('los-button-container') }
        };

        let engine, render, runner, stirrer, physicsActive = false;

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            try {
                initHeftUI();
                ladeEinstellungen();
                initSwipeLogic();
                startAppSequence();
                
                dom.btns.start.onclick = startGame;
                dom.btns.settings.onclick = showStart;
                dom.btns.back.onclick = showStart;
                dom.btns.los.onclick = triggerExplosion;
                dom.inputs.modeCount.onclick = () => setMode('count');
                dom.inputs.modeTime.onclick = () => setMode('time');
                dom.inputs.min.addEventListener('input', updateLabels);
                dom.inputs.max.addEventListener('input', updateLabels);
                
                dom.btns.stop.onclick = () => {
                    if (state.game.finished) { showEnd(); return; }
                    if (dom.btns.stop.classList.contains('confirm-mode')) endGameTimeUp();
                    else {
                        dom.btns.stop.classList.add('confirm-mode', 'bg-red-600', 'text-white', 'border-red-600');
                        dom.btns.stop.innerHTML = 'Sicher?';
                        setTimeout(() => {
                            dom.btns.stop.classList.remove('confirm-mode', 'bg-red-600', 'text-white', 'border-red-600');
                            dom.btns.stop.innerHTML = '<span class="flex items-center gap-1"><svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z"/></svg> Beenden</span>';
                        }, 3000);
                    }
                };

                window.addEventListener('resize', () => { if(physicsActive) resizePhysics(); adjustFontSize(); });
                document.addEventListener('mousemove', moveStirrer);
                document.addEventListener('touchmove', moveStirrer, {passive: false});
                document.addEventListener('touchstart', moveStirrer, {passive: false});
                document.addEventListener('mousedown', moveStirrer);
            } catch (e) {
                dom.intro.style.display = 'none';
                dom.app.classList.remove('hidden');
                dom.app.style.opacity = '1';
                dom.views.start.classList.remove('hidden');
                dom.views.start.classList.add('flex');
            }
        });

        // --- MEN√ú LOGIK ---
        function initHeftUI() {
            dom.inputs.heftContainer.innerHTML = HEFTE.map((h, i) => `
                <button class="heft-btn w-full text-left p-3 rounded-xl border-2 transition-all duration-200 flex flex-col" data-idx="${i}" onclick="selectHeft(${i})">
                    <span class="font-bold text-lg">Heft ${h.name}</span>
                    <span class="text-xs opacity-80 truncate w-full">${h.buchstaben.join(', ')}</span>
                </button>
            `).join('');
        }

        function selectHeft(index) {
            state.settings.heftIndex = index;
            // Buttons aktualisieren
            const buttons = dom.inputs.heftContainer.querySelectorAll('.heft-btn');
            buttons.forEach((btn, i) => {
                btn.className = 'heft-btn w-full text-left p-3 rounded-xl border-2 transition-all duration-200 flex flex-col'; // Reset
                if (i === index) {
                    // Aktiv (Aktuelles Heft)
                    btn.classList.add('border-blue-500', 'bg-blue-50', 'text-blue-800', 'shadow-sm');
                } else if (i < index) {
                    // Erledigt
                    btn.classList.add('border-blue-200', 'bg-blue-100', 'text-blue-900', 'opacity-70');
                } else {
                    // Zukunft
                    btn.classList.add('border-gray-200', 'bg-white', 'text-gray-400');
                }
            });

            updateBuchstabenUI(index);
        }

        function updateBuchstabenUI(idx, savedSelection = null) {
            // 1. Vorherige Buchstaben (implizit aktiv)
            let prevLetters = [];
            for(let i=0; i<idx; i++) prevLetters = prevLetters.concat(HEFTE[i].buchstaben);
            prevLetters = [...new Set(prevLetters)];
            dom.inputs.prevList.textContent = prevLetters.length > 0 ? prevLetters.join(', ') : '-';
            
            // 2. Aktuelle Buchstaben
            const currentLetters = HEFTE[idx].buchstaben;
            dom.inputs.container.innerHTML = currentLetters.map(b => {
                const checked = savedSelection ? savedSelection.includes(b) : true;
                return `<div class="flex items-center justify-center">
                    <input type="checkbox" id="cb-${b}" value="${b}" class="peer hidden" ${checked ? 'checked' : ''}>
                    <label for="cb-${b}" class="w-full text-center py-2 border-2 border-gray-200 rounded-lg cursor-pointer text-gray-600 font-bold select-none transition-colors peer-checked:border-blue-500 peer-checked:bg-blue-50 peer-checked:text-blue-600 text-sm sm:text-base bg-white shadow-sm hover:bg-gray-50">${b}</label>
                </div>`;
            }).join('');
        }

        function getAllAllowedLetters() {
            const idx = state.settings.heftIndex;
            let allowed = [];
            for(let i=0; i<idx; i++) allowed = allowed.concat(HEFTE[i].buchstaben);
            const checked = Array.from(dom.inputs.container.querySelectorAll('input:checked')).map(c => c.value);
            allowed = allowed.concat(checked);
            return [...new Set(allowed)];
        }

        function setMode(mode) {
            state.settings.mode = mode;
            const isCount = mode === 'count';
            dom.inputs.modeCount.className = `mode-btn flex-1 py-1.5 text-sm font-bold transition-colors ${isCount ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-600'}`;
            dom.inputs.modeTime.className = `mode-btn flex-1 py-1.5 text-sm font-bold transition-colors ${!isCount ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-600'}`;
            dom.inputs.countInput.classList.toggle('hidden', !isCount);
            dom.inputs.timeInput.classList.toggle('hidden', isCount);
        }

        function updateLabels() {
            dom.inputs.lblMin.textContent = `Min. ${dom.inputs.min.value} Silben`;
            dom.inputs.lblMax.textContent = `Max. ${dom.inputs.max.value} Silben`;
        }

        function startAppSequence() {
            setTimeout(() => {
                dom.intro.classList.add('fade-out');
                setTimeout(() => { dom.intro.style.display = 'none'; dom.app.classList.remove('hidden'); void dom.app.offsetWidth; dom.app.style.opacity = '1'; dom.views.start.classList.remove('hidden'); dom.views.start.classList.add('flex'); }, 500);
            }, 1500);
        }

        // --- GAME LOOP ---
        function startGame() {
            saveSettings();
            
            state.settings.currentLetters = getAllAllowedLetters();
            state.game = { runde: 0, richtig: 0, history: new Set(), colorIndex: 0, active: true, finished: false, letterStats: {}, startTimeGlobal: Date.now(), timerInterval: null };
            state.settings.currentLetters.forEach(b => state.game.letterStats[b] = 0);
            state.view = { zoom: 1, targetZoom: 1 };

            // Berechne m√∂gliche echte W√∂rter f√ºr diese Runde (f√ºr die Misch-Logik)
            calcPossibleRealWords();

            dom.views.start.classList.add('hidden'); dom.views.start.classList.remove('flex');
            dom.views.ende.classList.add('hidden'); dom.views.ende.classList.remove('flex');
            dom.views.spiel.classList.remove('hidden'); dom.views.spiel.classList.add('flex');
            dom.misc.losContainer.classList.add('hidden');
            dom.card.swipe.classList.remove('hidden');
            
            dom.card.swipe.style.transition = 'none'; dom.card.swipe.style.transform = 'scale(1)'; dom.card.swipe.style.opacity = '1'; dom.card.content.classList.remove('animate-pop-in'); dom.card.overlay.style.opacity = '0';

            if(state.settings.mode === 'time') {
                dom.btns.stop.classList.remove('hidden');
                dom.stats.progressText.parentElement.classList.remove('hidden');
                dom.stats.progressText.textContent = "0 W√∂rter";
            } else {
                dom.btns.stop.classList.add('hidden');
                dom.stats.progressText.parentElement.classList.remove('hidden');
            }

            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            state.game.timerInterval = setInterval(updateTimer, 1000);
            updateTimer();

            startPhysics();
            setTimeout(() => nextCard(true), 50);
        }

        function calcPossibleRealWords() {
             const allowedCharsFlat = new Set();
             state.settings.currentLetters.forEach(token => token.toUpperCase().split('').forEach(char => allowedCharsFlat.add(char)));
             
             state.game.realWordsPossible = WOERTERBUCH.filter(silben => {
                if(silben.length < state.settings.minSilben || silben.length > state.settings.maxSilben) return false;
                return silben.join('').toUpperCase().split('').every(c => allowedCharsFlat.has(c));
             });
        }

        function updateTimer() {
            const now = Date.now();
            let diff = 0;
            if (state.settings.mode === 'count') diff = now - state.game.startTimeGlobal;
            else {
                const endTime = state.game.startTimeGlobal + (state.settings.targetValue * 60 * 1000);
                diff = endTime - now;
                if (diff <= 0) { diff = 0; endGameTimeUp(); return; }
            }
            const sec = Math.floor(diff / 1000);
            dom.stats.timer.textContent = `${Math.floor(sec/60).toString().padStart(2,'0')}:${(sec%60).toString().padStart(2,'0')}`;
        }

        function showStart() {
            state.game.active = false;
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            stopPhysics();
            dom.views.spiel.classList.add('hidden'); dom.views.ende.classList.add('hidden');
            dom.views.start.classList.remove('hidden'); dom.views.start.classList.add('flex');
            dom.card.content.style.backgroundColor = 'white';
        }

        function endGameTimeUp() {
            if (state.game.finished) return;
            if (state.game.timerInterval) clearInterval(state.game.timerInterval);
            state.game.finished = true;
            dom.card.swipe.classList.add('hidden');
            if(world) Matter.Composite.allBodies(world).forEach(b => { Matter.Sleeping.set(b, false); b.sleepThreshold = -1; });
            if (state.settings.mode === 'time' && state.game.richtig === 0) showEnd();
        }

        function nextCard() {
            if (state.settings.mode === 'count' && state.game.runde >= state.settings.targetValue) { prepareEndPhase(); return; }
            if (state.settings.mode === 'time' && state.game.finished) return;

            dom.stats.progressText.textContent = state.settings.mode === 'count' ? `Wort ${state.game.runde + 1} / ${state.settings.targetValue}` : `${state.game.runde + 1} W√∂rter`;

            // --- WORT SELEKTION LOGIK (20er Regel + Keine Wiederholung) ---
            let wort = selectWordWithRules();
            
            // Sicherheitsnetz (sollte durch selectWordWithRules schon abgedeckt sein, aber zur Sicherheit)
            let versuche = 0;
            while (state.game.history.has(wort.join('')) && versuche < 30) {
                wort = selectWordWithRules();
                versuche++;
            }
            state.game.history.add(wort.join(''));
            
            const fullString = wort.join('').toUpperCase();
            state.settings.currentLetters.forEach(token => {
                if (fullString.includes(token.toUpperCase())) state.game.letterStats[token] = (state.game.letterStats[token] || 0) + 1;
            });

            dom.card.text.innerHTML = '';
            wort.forEach((silbe, i) => {
                const span = document.createElement('span');
                let text = silbe.toLowerCase();
                if (i === 0 && Math.random() < 0.8) text = text.charAt(0).toUpperCase() + text.slice(1);
                span.textContent = text;
                if (state.settings.farben) span.className = i % 2 === 0 ? 'text-blue-600' : 'text-red-600';
                if (state.settings.abstand && i < wort.length - 1) span.style.marginRight = '0.2em';
                dom.card.text.appendChild(span);
            });
            adjustFontSize();

            dom.card.swipe.style.transition = 'none'; dom.card.swipe.style.transform = 'scale(0.8)'; dom.card.swipe.style.opacity = '0'; dom.card.overlay.style.opacity = '0'; dom.card.content.style.backgroundColor = 'white';
            requestAnimationFrame(() => {
                dom.card.swipe.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)'; dom.card.swipe.style.transform = 'scale(1)'; dom.card.swipe.style.opacity = '1'; state.game.wordStartTime = Date.now();
            });
        }

        function selectWordWithRules() {
            const availableRealWords = state.game.realWordsPossible.length;
            const playedCount = state.game.runde + 1;

            // Regel 1: Alle 3 W√∂rter ein Fantasiewort, WENN zu wenig echte W√∂rter (<20)
            if (availableRealWords < 20 && playedCount % 3 === 0) {
                return generateFantasyWord(determineTargetLength());
            }

            // Regel 2: Versuche ein unbenutztes echtes Wort zu finden
            const unusedReal = state.game.realWordsPossible.filter(w => !state.game.history.has(w.join('')));
            if (unusedReal.length > 0) {
                return unusedReal[Math.floor(Math.random() * unusedReal.length)];
            }

            // Regel 3: Wenn keine echten W√∂rter mehr √ºbrig sind -> Fantasiewort
            return generateFantasyWord(determineTargetLength());
        }

        function determineTargetLength() {
            const min = state.settings.minSilben;
            const max = state.settings.maxSilben;
            if (min === max) return max;
            return Math.random() < 0.75 ? max : Math.floor(Math.random() * (max - 1 - min + 1)) + min;
        }

        function generateFantasyWord(length) {
            const v = state.settings.currentLetters.filter(b => VOKALE_LISTE.includes(b));
            const k = state.settings.currentLetters.filter(b => !VOKALE_LISTE.includes(b) && !DIPHTHONGE_LISTE.includes(b));
            const d = state.settings.currentLetters.filter(b => DIPHTHONGE_LISTE.includes(b));
            if (v.length === 0 && d.length === 0) return ["A".repeat(length).split('')]; 

            const pick = (pool) => {
                if (pool.length === 0) return '';
                // Bevorzuge Buchstaben die wenig genutzt wurden
                let minU = Infinity; pool.forEach(c => { if((state.game.letterStats[c]||0)<minU) minU=state.game.letterStats[c]||0; });
                const cands = pool.filter(c => (state.game.letterStats[c]||0)===minU);
                return cands[Math.floor(Math.random()*cands.length)];
            };

            const res = [];
            for(let i=0; i<length; i++) {
                let s='', type='KV';
                // Regeln f√ºr Fantasiew√∂rter vermeiden
                let attempts=0, valid=false;
                do {
                    if(Math.random()<0.1) type='V'; else type='KV';
                    s='';
                    if(type==='KV' && k.length>0) s += pick(k);
                    if(d.length>0 && Math.random()<0.2) s += pick(d); else if(v.length>0) s += pick(v);
                    
                    valid = true;
                    // Keine 3 gleichen Silben
                    if(length>=3 && i>0 && s===res[i-1]) valid=false;
                    // Keine Vokal-Kollision (Endet Vokal -> Startet Vokal)
                    if(i>0 && VOKALE_LISTE.includes(res[i-1].slice(-1).toUpperCase()) && VOKALE_LISTE.includes(s.charAt(0).toUpperCase())) valid=false;
                    attempts++;
                } while(!valid && attempts<10);
                res.push(s);
            }
            return res;
        }

        function handleResult(success) {
            if (success) {
                state.game.richtig++;
                const dur = Date.now() - state.game.wordStartTime;
                let f = 1.0; if(dur<2000) f=2.0; else if(dur>5000) f=0.5;
                spawnParticles(f);
            }
            state.game.runde++;
            setTimeout(nextCard, 300);
        }

        // --- SWIPE (Identisch) ---
        function initSwipeLogic() {
            let startX = 0, isDragging = false; const card = dom.card.swipe; const content = dom.card.content;
            const start = (x) => { if (state.game.finished) return; startX = x; isDragging = true; card.style.transition = 'none'; };
            const move = (x) => {
                if (!isDragging) return; const diff = x - startX; card.style.transform = `translate(${diff}px, 0) rotate(${diff * 0.05}deg)`;
                const op = Math.min(Math.abs(diff) / 150, 0.3);
                if (diff > 0) { content.style.backgroundColor = `rgba(34, 197, 94, ${0.1 + op * 0.5})`; dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-green-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M5 13l4 4L19 7"></path></svg>`; } 
                else { content.style.backgroundColor = `rgba(107, 114, 128, ${0.1 + op * 0.5})`; dom.card.overlay.innerHTML = `<svg class="w-32 h-32 text-gray-600 drop-shadow-md" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M6 18L18 6M6 6l12 12"></path></svg>`; }
                dom.card.overlay.style.opacity = Math.min(Math.abs(diff) / 100, 1);
            };
            const end = (x) => {
                if (!isDragging) return; isDragging = false; const diff = x - startX;
                if (Math.abs(diff) > 100) {
                    const dir = diff > 0 ? 1 : -1;
                    card.style.transition = 'transform 0.2s ease-out'; card.style.transform = `translate(${dir * 500}px, 0) rotate(${dir * 45}deg)`;
                    handleResult(dir === 1);
                } else {
                    card.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'; card.style.transform = 'translate(0,0) rotate(0)';
                    content.style.backgroundColor = 'white'; dom.card.overlay.style.opacity = '0';
                }
            };
            card.addEventListener('touchstart', e => start(e.touches[0].clientX)); window.addEventListener('touchmove', e => move(e.touches[0].clientX)); window.addEventListener('touchend', e => end(e.changedTouches[0].clientX));
            card.addEventListener('mousedown', e => start(e.clientX)); window.addEventListener('mousemove', e => move(e.clientX)); window.addEventListener('mouseup', e => end(e.clientX));
        }

        // --- PHYSICS & INTERACTION (Identisch) ---
        function startPhysics() {
            stopPhysics();
            const container = document.getElementById('2d-canvas-container');
            engine = Matter.Engine.create({ enableSleeping: true }); world = engine.world;
            render = Matter.Render.create({ element: container, engine: engine, options: { width: container.clientWidth, height: container.clientHeight, wireframes: false, background: 'transparent' } });
            createWalls(container.clientWidth, container.clientHeight);
            (function loop() {
                if (!engine) return; window.requestAnimationFrame(loop);
                Matter.Engine.update(engine, 1000/60);
                const ctx = render.context; ctx.clearRect(0, 0, w = render.canvas.width, h = render.canvas.height);
                ctx.save(); state.view.zoom += (state.view.targetZoom - state.view.zoom) * 0.05;
                ctx.translate(w/2, h/2); ctx.scale(state.view.zoom, state.view.zoom); ctx.translate(-w/2, -h/2);
                Matter.Composite.allBodies(world).forEach(b => {
                    if (b.label === 'wall' || b.label === 'stirrer') return;
                    ctx.beginPath(); ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, 2*Math.PI);
                    ctx.fillStyle = b.render.fillStyle; ctx.fill();
                });
                ctx.restore();
            })();
            physicsActive = true;
        }
        function stopPhysics() { engine = null; render = null; stirrer = null; physicsActive = false; document.getElementById('2d-canvas-container').innerHTML = ''; }
        function resizePhysics() { if(!render) return; render.canvas.width = document.getElementById('2d-canvas-container').clientWidth; render.canvas.height = document.getElementById('2d-canvas-container').clientHeight; createWalls(render.canvas.width, render.canvas.height); }
        function createWalls(w, h) {
            if(!world) return; Matter.Composite.clear(world, false, true); const th = 200; const opts = { isStatic: true, label: 'wall', friction: 1 };
            Matter.Composite.add(world, [Matter.Bodies.rectangle(w/2, h+th/2, w+200, th, opts), Matter.Bodies.rectangle(-th/2, h/2, th, h*2, opts), Matter.Bodies.rectangle(w+th/2, h/2, th, h*2, opts)]);
        }
        function spawnParticles(factor=1) {
            if(!engine) return; const w = render.canvas.width; const h = render.canvas.height;
            if(state.settings.mode === 'time') {
                const body = Matter.Bodies.circle(Math.random()*w*0.8+w*0.1, -50, 45, { restitution: 0.1, friction: 0.5, render: { fillStyle: RAINBOW_COLORS[state.game.colorIndex] } });
                Matter.Composite.add(world, body);
            } else {
                let count = Math.floor(((w*h*0.85)/(Math.PI*15*15*3)/state.settings.targetValue)*1.5 * factor);
                if(count<10) count=10; if(count>150) count=150;
                for(let i=0; i<count; i++) {
                    const body = Matter.Bodies.circle(Math.random()*w*0.8+w*0.1, -Math.random()*300-50, 15, { restitution: 0.1, friction: 0.5, render: { fillStyle: RAINBOW_COLORS[state.game.colorIndex] } });
                    Matter.Composite.add(world, body);
                }
            }
            state.game.colorIndex = (state.game.colorIndex+1)%RAINBOW_COLORS.length;
        }
        function adjustFontSize() { const el = dom.card.text; const p = dom.card.textContainer; let s = 4; el.style.fontSize = `${s}rem`; while((el.scrollWidth > p.clientWidth || el.scrollHeight > p.clientHeight) && s > 1) { s-=0.2; el.style.fontSize = `${s}rem`; } }
        function moveStirrer(e) {
            if (!state.game.finished || dom.misc.losContainer.classList.contains('hidden')) return;
            if(e.type === 'touchmove') e.preventDefault();
            const x = e.touches ? e.touches[0].clientX : e.clientX; const y = e.touches ? e.touches[0].clientY : e.clientY;
            if (!stirrer && engine) { stirrer = Matter.Bodies.circle(x, y, 80, { isStatic: true, label: 'stirrer' }); Matter.Composite.add(engine.world, stirrer); }
            else if (stirrer) Matter.Body.setPosition(stirrer, {x, y});
        }
        function prepareEndPhase() {
            if(state.game.timerInterval) clearInterval(state.game.timerInterval); state.game.finished = true;
            dom.card.swipe.classList.add('hidden');
            if(state.settings.mode==='count') dom.misc.losContainer.classList.remove('hidden');
            if(world) Matter.Composite.allBodies(world).forEach(b => { Matter.Sleeping.set(b, false); b.sleepThreshold = -1; });
            
            // Time Mode End Handler for Interaction
            if (state.settings.mode === 'time') {
                // Event listener ist schon global. Hier nur sicherstellen, dass wir wissen es ist ende.
                // Pr√ºfen ob schon leer? Nein, User muss platzen lassen.
                if(state.game.richtig === 0) showEnd(); // Wenn 0 W√∂rter, direkt Ende
            }
        }
        function triggerExplosion() {
            dom.misc.losContainer.classList.add('hidden'); if(stirrer) { Matter.Composite.remove(engine.world, stirrer); stirrer = null; }
            Matter.Composite.remove(engine.world, Matter.Composite.allBodies(engine.world).filter(b => b.label==='wall'));
            state.view.targetZoom = 0.4;
            Matter.Composite.allBodies(engine.world).forEach(b => { if(!b.isStatic) Matter.Body.applyForce(b, b.position, { x: (Math.random()-0.5)*1.5, y: -2.5-Math.random()*2 }); });
            setTimeout(showEnd, 4000);
        }
        
        // --- NEU: TIER BEWERTUNG ---
        function showEnd() {
            state.game.active = false; stopPhysics();
            dom.views.spiel.classList.add('hidden'); dom.views.ende.classList.remove('hidden'); dom.views.ende.classList.add('flex');
            
            dom.stats.resRight.textContent = state.game.richtig;
            const d = Date.now() - state.game.startTimeGlobal; 
            const secs = Math.floor(d/1000);
            dom.stats.resTime.textContent = `${Math.floor(secs/60).toString().padStart(2,'0')}:${(secs%60).toString().padStart(2,'0')}`;

            // WPM berechnen
            const minutes = secs / 60;
            const wpm = minutes > 0 ? state.game.richtig / minutes : 0;

            // Tier Leiter Rendern
            // Liste von unten (Langsam) nach oben (Schnell) = Reverse Order im Array f√ºr Visualisierung von Unten nach Oben
            // HTML Flex Col Reverse k√ºmmert sich drum
            
            let reachedLevelIdx = 0;
            // Finde h√∂chstes erreichtes Level
            for (let i=0; i<ANIMALS.length; i++) {
                if (wpm >= ANIMALS[i].wpm) reachedLevelIdx = i;
            }
            if (state.game.richtig === 0) reachedLevelIdx = -1; // Nichts erreicht

            dom.stats.animals.innerHTML = ANIMALS.map((anim, i) => {
                const isActive = i === reachedLevelIdx;
                return `<div class="text-6xl transition-all duration-500 ${isActive ? 'active-animal' : 'grayscale-icon'}">${anim.icon}</div>`;
            }).reverse().join(''); // Reverse damit Gepard oben ist
        }

        function handleInteractionStart(e) {
            if(!state.game.finished || state.settings.mode !== 'time') return;
            const x = e.touches ? e.touches[0].clientX : e.clientX; const y = e.touches ? e.touches[0].clientY : e.clientY;
            const clicked = Matter.Query.point(Matter.Composite.allBodies(world), {x, y});
            let removed = false;
            clicked.forEach(b => { if(!b.isStatic && b.label!=='wall') { Matter.Composite.remove(world, b); createConfetti(b.position.x, b.position.y, b.render.fillStyle); removed=true; } });
            // Check if empty
            if(removed && Matter.Composite.allBodies(world).filter(b=>!b.isStatic && b.label!=='wall').length===0) setTimeout(showEnd, 1000);
        }
        function createConfetti(x, y, c) {
            for(let i=0; i<20; i++) { const p = Matter.Bodies.circle(x, y, 4, { render: { fillStyle: c }, frictionAir: 0.02, restitution: 0.6 }); Matter.Body.setVelocity(p, { x: (Math.random()-0.5)*30, y: (Math.random()-0.5)*30 }); Matter.Composite.add(world, p); setTimeout(() => { if(world) Matter.Composite.remove(world, p); }, 2000); }
        }
        document.addEventListener('mousedown', handleInteractionStart); document.addEventListener('touchstart', handleInteractionStart, {passive: false});

        function saveSettings() {
            const checked = dom.inputs.container.querySelectorAll('input:checked');
            const d = { heftIndex: dom.inputs.heftSelect.value, buchstaben: Array.from(checked).map(c => c.value), minSilben: parseInt(dom.inputs.min.value), maxSilben: parseInt(dom.inputs.max.value), mode: state.settings.mode, targetValue: state.settings.mode === 'count' ? parseInt(dom.inputs.valCount.value) : parseInt(dom.inputs.valTime.value), farben: dom.inputs.color.checked, abstand: dom.inputs.gap.checked };
            if (d.minSilben > d.maxSilben) d.minSilben = d.maxSilben;
            state.settings = d; try { localStorage.setItem('leseAppConf', JSON.stringify(d)); } catch(e) {}
        }
        function ladeEinstellungen() {
            let d = { heftIndex: 1, buchstaben: ['A','M','O','L','I'], minSilben: 1, maxSilben: 2, mode: 'count', targetValue: 10, farben: true, abstand: false };
            try { const s = localStorage.getItem('leseAppConf'); if(s) { const p = JSON.parse(s); d = {...d, ...p}; } } catch(e){}
            state.settings = d; dom.inputs.min.value = d.minSilben; dom.inputs.max.value = d.maxSilben; dom.inputs.color.checked = d.farben; dom.inputs.gap.checked = d.abstand; dom.inputs.heftSelect.value = d.heftIndex || 1;
            setMode(d.mode); if(d.mode==='count') dom.inputs.valCount.value = d.targetValue; else dom.inputs.valTime.value = d.targetValue;
            selectHeft(parseInt(d.heftIndex || 1));
            updateLabels();
        }
    </script>
</body>
</html>
